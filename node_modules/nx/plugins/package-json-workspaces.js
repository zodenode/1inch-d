"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGlobPatternsFromPackageManagerWorkspaces = exports.buildProjectConfigurationFromPackageJson = exports.createNodeFromPackageJson = exports.getNxPackageJsonWorkspacesPlugin = void 0;
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
const nx_json_1 = require("../src/config/nx-json");
const workspaces_1 = require("../src/config/workspaces");
const fileutils_1 = require("../src/utils/fileutils");
const globs_1 = require("../src/utils/globs");
const logger_1 = require("../src/utils/logger");
const output_1 = require("../src/utils/output");
const package_json_1 = require("../src/utils/package-json");
const path_1 = require("../src/utils/path");
function getNxPackageJsonWorkspacesPlugin(root) {
    const readJson = (f) => (0, fileutils_1.readJsonFile)((0, node_path_1.join)(root, f));
    return {
        name: 'nx-core-build-package-json-nodes',
        createNodes: [
            (0, globs_1.combineGlobPatterns)(getGlobPatternsFromPackageManagerWorkspaces(root, readJson)),
            (p) => createNodeFromPackageJson(p, root),
        ],
    };
}
exports.getNxPackageJsonWorkspacesPlugin = getNxPackageJsonWorkspacesPlugin;
function createNodeFromPackageJson(pkgJsonPath, root) {
    const json = (0, fileutils_1.readJsonFile)((0, node_path_1.join)(root, pkgJsonPath));
    return {
        projects: {
            [json.name]: buildProjectConfigurationFromPackageJson(json, pkgJsonPath, (0, nx_json_1.readNxJson)(root)),
        },
    };
}
exports.createNodeFromPackageJson = createNodeFromPackageJson;
function buildProjectConfigurationFromPackageJson(packageJson, path, nxJson) {
    var _a, _b, _c, _d;
    const normalizedPath = path.split('\\').join('/');
    const directory = (0, node_path_1.dirname)(normalizedPath);
    if (!packageJson.name && directory === '.') {
        throw new Error('Nx requires the root package.json to specify a name if it is being used as an Nx project.');
    }
    let name = (_a = packageJson.name) !== null && _a !== void 0 ? _a : (0, workspaces_1.toProjectName)(normalizedPath);
    if (nxJson === null || nxJson === void 0 ? void 0 : nxJson.npmScope) {
        const npmPrefix = `@${nxJson.npmScope}/`;
        if (name.startsWith(npmPrefix)) {
            name = name.replace(npmPrefix, '');
        }
    }
    const projectType = ((_b = nxJson === null || nxJson === void 0 ? void 0 : nxJson.workspaceLayout) === null || _b === void 0 ? void 0 : _b.appsDir) != ((_c = nxJson === null || nxJson === void 0 ? void 0 : nxJson.workspaceLayout) === null || _c === void 0 ? void 0 : _c.libsDir) &&
        ((_d = nxJson === null || nxJson === void 0 ? void 0 : nxJson.workspaceLayout) === null || _d === void 0 ? void 0 : _d.appsDir) &&
        directory.startsWith(nxJson.workspaceLayout.appsDir)
        ? 'application'
        : 'library';
    return Object.assign(Object.assign({ root: directory, sourceRoot: directory, name,
        projectType }, packageJson.nx), { targets: (0, package_json_1.readTargetsFromPackageJson)(packageJson) });
}
exports.buildProjectConfigurationFromPackageJson = buildProjectConfigurationFromPackageJson;
/**
 * Get the package.json globs from package manager workspaces
 */
function getGlobPatternsFromPackageManagerWorkspaces(root, readJson = (path) => (0, fileutils_1.readJsonFile)((0, node_path_1.join)(root, path)) // making this an arg allows us to reuse in devkit
) {
    var _a, _b;
    try {
        const patterns = [];
        const packageJson = readJson('package.json');
        patterns.push(...normalizePatterns(Array.isArray(packageJson.workspaces)
            ? packageJson.workspaces
            : (_b = (_a = packageJson.workspaces) === null || _a === void 0 ? void 0 : _a.packages) !== null && _b !== void 0 ? _b : []));
        if ((0, node_fs_1.existsSync)((0, node_path_1.join)(root, 'pnpm-workspace.yaml'))) {
            try {
                const { packages } = (0, fileutils_1.readYamlFile)((0, node_path_1.join)(root, 'pnpm-workspace.yaml'));
                patterns.push(...normalizePatterns(packages || []));
            }
            catch (e) {
                output_1.output.warn({
                    title: `${logger_1.NX_PREFIX} Unable to parse pnpm-workspace.yaml`,
                    bodyLines: [e.toString()],
                });
            }
        }
        if ((0, node_fs_1.existsSync)((0, node_path_1.join)(root, 'lerna.json'))) {
            try {
                const { packages } = readJson('lerna.json');
                patterns.push(...normalizePatterns((packages === null || packages === void 0 ? void 0 : packages.length) > 0 ? packages : ['packages/*']));
            }
            catch (e) {
                output_1.output.warn({
                    title: `${logger_1.NX_PREFIX} Unable to parse lerna.json`,
                    bodyLines: [e.toString()],
                });
            }
        }
        // Merge patterns from workspaces definitions
        // TODO(@AgentEnder): update logic after better way to determine root project inclusion
        // Include the root project
        return packageJson.nx ? patterns.concat('package.json') : patterns;
    }
    catch (_c) {
        return [];
    }
}
exports.getGlobPatternsFromPackageManagerWorkspaces = getGlobPatternsFromPackageManagerWorkspaces;
function normalizePatterns(patterns) {
    return patterns.map((pattern) => removeRelativePath(pattern.endsWith('/package.json')
        ? pattern
        : (0, path_1.joinPathFragments)(pattern, 'package.json')));
}
function removeRelativePath(pattern) {
    return pattern.startsWith('./') ? pattern.substring(2) : pattern;
}
