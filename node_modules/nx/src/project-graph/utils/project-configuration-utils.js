"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readTargetDefaultsForTarget = exports.resolveNxTokensInOptions = exports.mergeTargetConfigurations = exports.readProjectConfigurationsFromRootMap = exports.buildProjectsConfigurationsFromProjectPathsAndPlugins = exports.mergeProjectConfigurationIntoRootMap = void 0;
const tslib_1 = require("tslib");
const node_path_1 = require("node:path");
const package_json_workspaces_1 = require("../../../plugins/package-json-workspaces");
const project_json_1 = require("../../../plugins/project-json");
const logger_1 = require("../../utils/logger");
const workspace_root_1 = require("../../utils/workspace-root");
const minimatch = require("minimatch");
function mergeProjectConfigurationIntoRootMap(projectRootMap, project, 
// project.json is a special case, so we need to detect it.
file) {
    const matchingProject = projectRootMap.get(project.root);
    if (!matchingProject) {
        projectRootMap.set(project.root, project);
        return;
    }
    else if (project.name &&
        project.name !== matchingProject.name &&
        (0, node_path_1.basename)(file) === 'project.json') {
        // `name` inside project.json overrides any names from
        // inference plugins
        matchingProject.name = project.name;
    }
    // This handles top level properties that are overwritten.
    // e.g. `srcRoot`, `projectType`, or other fields that shouldn't be extended
    // Note: `name` is set specifically here to keep it from changing. The name is
    // always determined by the first inference plugin to ID a project, unless it has
    // a project.json in which case it was already updated above.
    const updatedProjectConfiguration = Object.assign(Object.assign(Object.assign({}, matchingProject), project), { name: matchingProject.name });
    // The next blocks handle properties that should be themselves merged (e.g. targets, tags, and implicit dependencies)
    if (project.tags && matchingProject.tags) {
        updatedProjectConfiguration.tags = matchingProject.tags.concat(project.tags);
    }
    if (project.implicitDependencies && matchingProject.tags) {
        updatedProjectConfiguration.implicitDependencies =
            matchingProject.implicitDependencies.concat(project.implicitDependencies);
    }
    if (project.generators && matchingProject.generators) {
        updatedProjectConfiguration.generators = Object.assign(Object.assign({}, matchingProject.generators), project.generators);
    }
    if (project.targets && matchingProject.targets) {
        updatedProjectConfiguration.targets = Object.assign(Object.assign({}, matchingProject.targets), project.targets);
    }
    projectRootMap.set(updatedProjectConfiguration.root, updatedProjectConfiguration);
}
exports.mergeProjectConfigurationIntoRootMap = mergeProjectConfigurationIntoRootMap;
function buildProjectsConfigurationsFromProjectPathsAndPlugins(nxJson, projectFiles, // making this parameter allows devkit to pick up newly created projects
plugins, root = workspace_root_1.workspaceRoot) {
    var _a, _b;
    var _c;
    const projectRootMap = new Map();
    const externalNodes = {};
    // We push the nx core node builder onto the end, s.t. it overwrites any user specified behavior
    plugins.push((0, package_json_workspaces_1.getNxPackageJsonWorkspacesPlugin)(root), (0, project_json_1.getNxProjectJsonPlugin)(root));
    // We iterate over plugins first - this ensures that plugins specified first take precedence.
    for (const plugin of plugins) {
        const [pattern, configurationConstructor] = (_a = plugin.createNodes) !== null && _a !== void 0 ? _a : [];
        if (!pattern) {
            continue;
        }
        for (const file of projectFiles) {
            if (minimatch(file, pattern, { dot: true })) {
                const { projects: projectNodes, externalNodes: pluginExternalNodes } = configurationConstructor(file, {
                    nxJsonConfiguration: nxJson,
                    workspaceRoot: root,
                });
                for (const node in projectNodes) {
                    (_b = (_c = projectNodes[node]).name) !== null && _b !== void 0 ? _b : (_c.name = node);
                    mergeProjectConfigurationIntoRootMap(projectRootMap, projectNodes[node], file);
                }
                Object.assign(externalNodes, pluginExternalNodes);
            }
        }
    }
    return {
        projects: readProjectConfigurationsFromRootMap(projectRootMap),
        externalNodes,
    };
}
exports.buildProjectsConfigurationsFromProjectPathsAndPlugins = buildProjectsConfigurationsFromProjectPathsAndPlugins;
function readProjectConfigurationsFromRootMap(projectRootMap) {
    var _a;
    const projects = {};
    // If there are projects that have the same name, that is an error.
    // This object tracks name -> (all roots of projects with that name)
    // to provide better error messaging.
    const errors = new Map();
    for (const [root, configuration] of projectRootMap.entries()) {
        if (!configuration.name) {
            throw new Error(`Project at ${root} has no name provided.`);
        }
        else if (configuration.name in projects) {
            let rootErrors = (_a = errors.get(configuration.name)) !== null && _a !== void 0 ? _a : [
                projects[configuration.name].root,
            ];
            rootErrors.push(root);
            errors.set(configuration.name, rootErrors);
        }
        else {
            projects[configuration.name] = configuration;
        }
    }
    if (errors.size > 0) {
        throw new Error([
            `The following projects are defined in multiple locations:`,
            ...Array.from(errors.entries()).map(([project, roots]) => [`- ${project}: `, ...roots.map((r) => `  - ${r}`)].join('\n')),
            '',
            "To fix this, set a unique name for each project in a project.json inside the project's root. If the project does not currently have a project.json, you can create one that contains only a name.",
        ].join('\n'));
    }
    return projects;
}
exports.readProjectConfigurationsFromRootMap = readProjectConfigurationsFromRootMap;
function mergeTargetConfigurations(projectConfiguration, target, targetDefaults) {
    var _a;
    const targetConfiguration = (_a = projectConfiguration.targets) === null || _a === void 0 ? void 0 : _a[target];
    if (!targetConfiguration) {
        throw new Error(`Attempted to merge targetDefaults for ${projectConfiguration.name}.${target}, which doesn't exist.`);
    }
    const { configurations: defaultConfigurations, options: defaultOptions } = targetDefaults, defaults = tslib_1.__rest(targetDefaults, ["configurations", "options"]);
    const result = Object.assign(Object.assign({}, defaults), targetConfiguration);
    // Target is "compatible", e.g. executor is defined only once or is the same
    // in both places. This means that it is likely safe to merge options
    if (!targetDefaults.executor ||
        !targetConfiguration.executor ||
        targetDefaults.executor === targetConfiguration.executor) {
        result.options = Object.assign(Object.assign({}, defaultOptions), targetConfiguration === null || targetConfiguration === void 0 ? void 0 : targetConfiguration.options);
        result.configurations = mergeConfigurations(defaultConfigurations, targetConfiguration.configurations);
    }
    return result;
}
exports.mergeTargetConfigurations = mergeTargetConfigurations;
function mergeConfigurations(defaultConfigurations, projectDefinedConfigurations) {
    var _a, _b;
    const result = {};
    const configurations = new Set([
        ...Object.keys(defaultConfigurations !== null && defaultConfigurations !== void 0 ? defaultConfigurations : {}),
        ...Object.keys(projectDefinedConfigurations !== null && projectDefinedConfigurations !== void 0 ? projectDefinedConfigurations : {}),
    ]);
    for (const configuration of configurations) {
        result[configuration] = Object.assign(Object.assign({}, ((_a = defaultConfigurations === null || defaultConfigurations === void 0 ? void 0 : defaultConfigurations[configuration]) !== null && _a !== void 0 ? _a : {})), ((_b = projectDefinedConfigurations === null || projectDefinedConfigurations === void 0 ? void 0 : projectDefinedConfigurations[configuration]) !== null && _b !== void 0 ? _b : {}));
    }
    return result;
}
function resolveNxTokensInOptions(object, project, key) {
    const result = Array.isArray(object) ? [...object] : Object.assign({}, object);
    for (let [opt, value] of Object.entries(object !== null && object !== void 0 ? object : {})) {
        if (typeof value === 'string') {
            const workspaceRootMatch = /^(\{workspaceRoot\}\/?)/.exec(value);
            if (workspaceRootMatch === null || workspaceRootMatch === void 0 ? void 0 : workspaceRootMatch.length) {
                value = value.replace(workspaceRootMatch[0], '');
            }
            if (value.includes('{workspaceRoot}')) {
                throw new Error(`${logger_1.NX_PREFIX} The {workspaceRoot} token is only valid at the beginning of an option. (${key})`);
            }
            value = value.replace(/\{projectRoot\}/g, project.root);
            result[opt] = value.replace(/\{projectName\}/g, project.name);
        }
        else if (typeof value === 'object' && value) {
            result[opt] = resolveNxTokensInOptions(value, project, [key, opt].join('.'));
        }
    }
    return result;
}
exports.resolveNxTokensInOptions = resolveNxTokensInOptions;
function readTargetDefaultsForTarget(targetName, targetDefaults, executor) {
    if (executor) {
        // If an executor is defined in project.json, defaults should be read
        // from the most specific key that matches that executor.
        // e.g. If executor === run-commands, and the target is named build:
        // Use, use nx:run-commands if it is present
        // If not, use build if it is present.
        const key = [executor, targetName].find((x) => targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults[x]);
        return key ? targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults[key] : null;
    }
    else {
        // If the executor is not defined, the only key we have is the target name.
        return targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults[targetName];
    }
}
exports.readTargetDefaultsForTarget = readTargetDefaultsForTarget;
