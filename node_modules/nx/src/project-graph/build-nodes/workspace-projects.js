"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeImplicitDependencies = exports.normalizeProjectTargets = exports.normalizeProjectNodes = void 0;
const tslib_1 = require("tslib");
const find_matching_projects_1 = require("../../utils/find-matching-projects");
const logger_1 = require("../../utils/logger");
const project_configuration_utils_1 = require("../utils/project-configuration-utils");
function normalizeProjectNodes(ctx, builder, nxJson) {
    var _a, _b;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const toAdd = [];
        const projects = Object.keys(ctx.projectsConfigurations.projects);
        // Used for expanding implicit dependencies (e.g. `@proj/*` or `tag:foo`)
        const partialProjectGraphNodes = projects.reduce((graph, project) => {
            const projectConfiguration = ctx.projectsConfigurations.projects[project];
            graph[project] = {
                name: project,
                type: projectConfiguration.projectType === 'library' ? 'lib' : 'app',
                data: Object.assign({}, projectConfiguration),
            };
            return graph;
        }, {});
        for (const key of projects) {
            const p = ctx.projectsConfigurations.projects[key];
            p.implicitDependencies = normalizeImplicitDependencies(key, p.implicitDependencies, partialProjectGraphNodes);
            p.targets = normalizeProjectTargets(p, nxJson.targetDefaults, key);
            // TODO: remove in v16
            const projectType = p.projectType === 'application'
                ? key.endsWith('-e2e') || key === 'e2e'
                    ? 'e2e'
                    : 'app'
                : 'lib';
            const tags = ((_b = (_a = ctx.projectsConfigurations.projects) === null || _a === void 0 ? void 0 : _a[key]) === null || _b === void 0 ? void 0 : _b.tags) || [];
            toAdd.push({
                name: key,
                type: projectType,
                data: Object.assign(Object.assign({}, p), { tags }),
            });
        }
        // Sort by root directory length (do we need this?)
        toAdd.sort((a, b) => {
            if (!a.data.root)
                return -1;
            if (!b.data.root)
                return -1;
            return a.data.root.length > b.data.root.length ? -1 : 1;
        });
        toAdd.forEach((n) => {
            builder.addNode({
                name: n.name,
                type: n.type,
                data: n.data,
            });
        });
    });
}
exports.normalizeProjectNodes = normalizeProjectNodes;
/**
 * Apply target defaults and normalization
 */
function normalizeProjectTargets(project, targetDefaults, projectName) {
    var _a, _b, _c;
    var _d;
    // Any node on the graph will have a targets object, it just may be empty
    const targets = (_a = project.targets) !== null && _a !== void 0 ? _a : {};
    for (const target in targets) {
        // We need to know the executor for use in readTargetDefaultsForTarget,
        // but we haven't resolved the `command` syntactic sugar yet.
        const executor = (_b = targets[target].executor) !== null && _b !== void 0 ? _b : (targets[target].command ? 'nx:run-commands' : null);
        // Allows things like { targetDefaults: { build: { command: tsc } } }
        const defaults = resolveCommandSyntacticSugar((0, project_configuration_utils_1.readTargetDefaultsForTarget)(target, targetDefaults, executor), `targetDefaults:${target}`);
        targets[target] = resolveCommandSyntacticSugar(targets[target], `${projectName}:${target}`);
        if (defaults) {
            targets[target] = (0, project_configuration_utils_1.mergeTargetConfigurations)(project, target, defaults);
        }
        targets[target].options = (0, project_configuration_utils_1.resolveNxTokensInOptions)(targets[target].options, project, `${projectName}:${target}`);
        (_c = (_d = targets[target]).configurations) !== null && _c !== void 0 ? _c : (_d.configurations = {});
        for (const configuration in targets[target].configurations) {
            targets[target].configurations[configuration] = (0, project_configuration_utils_1.resolveNxTokensInOptions)(targets[target].configurations[configuration], project, `${projectName}:${target}:${configuration}`);
        }
    }
    return targets;
}
exports.normalizeProjectTargets = normalizeProjectTargets;
function normalizeImplicitDependencies(source, implicitDependencies, projects) {
    if (!(implicitDependencies === null || implicitDependencies === void 0 ? void 0 : implicitDependencies.length)) {
        return implicitDependencies !== null && implicitDependencies !== void 0 ? implicitDependencies : [];
    }
    const matches = (0, find_matching_projects_1.findMatchingProjects)(implicitDependencies, projects);
    return (matches
        .filter((x) => x !== source)
        // implicit dependencies that start with ! should hang around, to be processed by
        // implicit-project-dependencies.ts after explicit deps are added to graph.
        .concat(implicitDependencies.filter((x) => x.startsWith('!'))));
}
exports.normalizeImplicitDependencies = normalizeImplicitDependencies;
function resolveCommandSyntacticSugar(target, key) {
    const _a = target !== null && target !== void 0 ? target : {}, { command } = _a, config = tslib_1.__rest(_a, ["command"]);
    if (!command) {
        return target;
    }
    if (config.executor) {
        throw new Error(`${logger_1.NX_PREFIX} ${key} should not have executor and command both configured.`);
    }
    else {
        return Object.assign(Object.assign({}, config), { executor: 'nx:run-commands', options: Object.assign(Object.assign({}, config.options), { command: command }) });
    }
}
