"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildExplicitTypeScriptDependencies = void 0;
const typescript_import_locator_1 = require("./typescript-import-locator");
const target_project_locator_1 = require("./target-project-locator");
const project_graph_1 = require("../../../../config/project-graph");
const path_1 = require("path");
const workspace_root_1 = require("../../../../utils/workspace-root");
const path_2 = require("../../../../utils/path");
function buildExplicitTypeScriptDependencies(graph, filesToProcess) {
    let results;
    if (process.env.NX_NATIVE_TS_DEPS !== 'false') {
        results = buildExplicitTypeScriptDependenciesWithSwc(filesToProcess, graph);
    }
    else {
        results = buildExplicitTypeScriptDependenciesWithTs(filesToProcess, graph);
    }
    if (process.env.NX_NATIVE_TS_DEPS &&
        process.env.NX_NATIVE_TS_DEPS === 'debug') {
        const tsResults = buildExplicitTypeScriptDependenciesWithTs(filesToProcess, graph);
        const set = new Set();
        for (const dep of results) {
            set.add(`+ ${dep.sourceProjectName} -> ${dep.targetProjectName} (${dep.sourceProjectFile})`);
        }
        for (const dep of tsResults) {
            set.delete(`+ ${dep.sourceProjectName} -> ${dep.targetProjectName} (${dep.sourceProjectFile})`);
            set.add(`- ${dep.sourceProjectName} -> ${dep.targetProjectName} (${dep.sourceProjectFile})`);
        }
        for (const dep of results) {
            set.delete(`- ${dep.sourceProjectName} -> ${dep.targetProjectName} (${dep.sourceProjectFile})`);
        }
        set.forEach((s) => console.log(s));
    }
    return results;
}
exports.buildExplicitTypeScriptDependencies = buildExplicitTypeScriptDependencies;
function isRoot(graph, projectName) {
    var _a, _b;
    return ((_b = (_a = graph.nodes[projectName]) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.root) === '.';
}
function convertImportToDependency(importExpr, file, sourceProject, type, targetProjectLocator) {
    const target = targetProjectLocator.findProjectWithImport(importExpr, file);
    let targetProjectName;
    if (target) {
        targetProjectName = target;
    }
    else {
        // treat all unknowns as npm packages, they can be eiher
        // - mistyped local import, which has to be fixed manually
        // - node internals, which should still be tracked as a dependency
        // - npm packages, which are not yet installed but should be tracked
        targetProjectName = `npm:${importExpr}`;
    }
    return {
        sourceProjectName: sourceProject,
        targetProjectName,
        sourceProjectFile: file,
        type,
    };
}
function buildExplicitTypeScriptDependenciesWithSwc(projectFileMap, graph) {
    var _a;
    const targetProjectLocator = new target_project_locator_1.TargetProjectLocator(graph.nodes, graph.externalNodes);
    const res = [];
    const filesToProcess = {};
    const moduleExtensions = ['.ts', '.js', '.tsx', '.jsx', '.mts', '.mjs'];
    for (const [project, fileData] of Object.entries(projectFileMap)) {
        (_a = filesToProcess[project]) !== null && _a !== void 0 ? _a : (filesToProcess[project] = []);
        for (const { file } of fileData) {
            if (moduleExtensions.some((ext) => file.endsWith(ext))) {
                filesToProcess[project].push((0, path_1.join)(workspace_root_1.workspaceRoot, file));
            }
        }
    }
    const { findImports } = require('../../../../native');
    const imports = findImports(filesToProcess);
    for (const { sourceProject, file, staticImportExpressions, dynamicImportExpressions, } of imports) {
        const normalizedFilePath = (0, path_2.normalizePath)((0, path_1.relative)(workspace_root_1.workspaceRoot, file));
        for (const importExpr of staticImportExpressions) {
            const dependency = convertImportToDependency(importExpr, normalizedFilePath, sourceProject, project_graph_1.DependencyType.static, targetProjectLocator);
            // TODO: These edges technically should be allowed but we need to figure out how to separate config files out from root
            if (isRoot(graph, dependency.sourceProjectName) ||
                !isRoot(graph, dependency.targetProjectName)) {
                res.push(dependency);
            }
        }
        for (const importExpr of dynamicImportExpressions) {
            const dependency = convertImportToDependency(importExpr, normalizedFilePath, sourceProject, project_graph_1.DependencyType.dynamic, targetProjectLocator);
            // TODO: These edges technically should be allowed but we need to figure out how to separate config files out from root
            if (isRoot(graph, dependency.sourceProjectName) ||
                !isRoot(graph, dependency.targetProjectName)) {
                res.push(dependency);
            }
        }
    }
    return res;
}
function buildExplicitTypeScriptDependenciesWithTs(filesToProcess, graph) {
    const importLocator = new typescript_import_locator_1.TypeScriptImportLocator();
    const targetProjectLocator = new target_project_locator_1.TargetProjectLocator(graph.nodes, graph.externalNodes);
    const res = [];
    Object.keys(filesToProcess).forEach((source) => {
        Object.values(filesToProcess[source]).forEach((f) => {
            importLocator.fromFile(f.file, (importExpr, filePath, type) => {
                const target = targetProjectLocator.findProjectWithImport(importExpr, f.file);
                let targetProjectName;
                if (target) {
                    if (!isRoot(graph, source) && isRoot(graph, target)) {
                        // TODO: These edges technically should be allowed but we need to figure out how to separate config files out from root
                        return;
                    }
                    targetProjectName = target;
                }
                else {
                    // treat all unknowns as npm packages, they can be eiher
                    // - mistyped local import, which has to be fixed manually
                    // - node internals, which should still be tracked as a dependency
                    // - npm packages, which are not yet installed but should be tracked
                    targetProjectName = `npm:${importExpr}`;
                }
                res.push({
                    sourceProjectName: source,
                    targetProjectName,
                    sourceProjectFile: f.file,
                    type,
                });
            });
        });
    });
    return res;
}
