"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterUsingGlobPatterns = exports.expandNamedInput = exports.getInputs = exports.extractPatternsFromFileSets = exports.getTargetInputs = exports.getNamedInputs = exports.InProcessTaskHasher = exports.DaemonBasedTaskHasher = void 0;
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const minimatch = require("minimatch");
const hasher_1 = require("../plugins/js/hasher/hasher");
const find_project_for_path_1 = require("../project-graph/utils/find-project-for-path");
const find_matching_projects_1 = require("../utils/find-matching-projects");
const file_hasher_1 = require("./file-hasher");
const utils_1 = require("../tasks-runner/utils");
const set_hash_env_1 = require("./set-hash-env");
const workspace_root_1 = require("../utils/workspace-root");
const path_1 = require("path");
const path_2 = require("../utils/path");
const project_graph_utils_1 = require("../utils/project-graph-utils");
class DaemonBasedTaskHasher {
    constructor(daemonClient, runnerOptions) {
        this.daemonClient = daemonClient;
        this.runnerOptions = runnerOptions;
    }
    hashTasks(tasks, taskGraph) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.daemonClient.hashTasks(this.runnerOptions, tasks, taskGraph);
        });
    }
    hashTask(task, taskGraph) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.daemonClient.hashTasks(this.runnerOptions, [task], taskGraph))[0];
        });
    }
}
exports.DaemonBasedTaskHasher = DaemonBasedTaskHasher;
class InProcessTaskHasher {
    constructor(projectFileMap, allWorkspaceFiles, projectGraph, nxJson, options, fileHasher) {
        var _a;
        this.projectFileMap = projectFileMap;
        this.allWorkspaceFiles = allWorkspaceFiles;
        this.projectGraph = projectGraph;
        this.nxJson = nxJson;
        this.options = options;
        this.fileHasher = fileHasher;
        const legacyRuntimeInputs = (this.options && this.options.runtimeCacheInputs
            ? this.options.runtimeCacheInputs
            : []).map((r) => ({ runtime: r }));
        if (process.env.NX_CLOUD_ENCRYPTION_KEY) {
            legacyRuntimeInputs.push({ env: 'NX_CLOUD_ENCRYPTION_KEY' });
        }
        const legacyFilesetInputs = [
            'nx.json',
            // ignore files will change the set of inputs to the hasher
            '.gitignore',
            '.nxignore',
        ].map((d) => ({ fileset: `{workspaceRoot}/${d}` }));
        this.taskHasher = new TaskHasherImpl(nxJson, legacyRuntimeInputs, legacyFilesetInputs, this.projectFileMap, this.allWorkspaceFiles, this.projectGraph, this.fileHasher, { selectivelyHashTsConfig: (_a = this.options.selectivelyHashTsConfig) !== null && _a !== void 0 ? _a : false });
    }
    hashTasks(tasks, taskGraph) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield Promise.all(tasks.map((t) => this.hashTask(t, taskGraph)));
        });
    }
    hashTask(task, taskGraph) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const res = yield this.taskHasher.hashTask(task, taskGraph, [
                task.target.project,
            ]);
            const command = this.hashCommand(task);
            return {
                value: (0, file_hasher_1.hashArray)([res.value, command]),
                details: {
                    command,
                    nodes: res.details,
                    implicitDeps: {},
                    runtime: {},
                },
            };
        });
    }
    hashCommand(task) {
        var _a, _b, _c;
        const overrides = Object.assign({}, task.overrides);
        delete overrides['__overrides_unparsed__'];
        const sortedOverrides = {};
        for (let k of Object.keys(overrides).sort()) {
            sortedOverrides[k] = overrides[k];
        }
        return (0, file_hasher_1.hashArray)([
            (_a = task.target.project) !== null && _a !== void 0 ? _a : '',
            (_b = task.target.target) !== null && _b !== void 0 ? _b : '',
            (_c = task.target.configuration) !== null && _c !== void 0 ? _c : '',
            JSON.stringify(sortedOverrides),
        ]);
    }
}
exports.InProcessTaskHasher = InProcessTaskHasher;
InProcessTaskHasher.version = '3.0';
const DEFAULT_INPUTS = [
    {
        fileset: '{projectRoot}/**/*',
    },
    {
        dependencies: true,
        input: 'default',
    },
];
class TaskHasherImpl {
    constructor(nxJson, legacyRuntimeInputs, legacyFilesetInputs, projectFileMap, allWorkspaceFiles, projectGraph, fileHasher, options) {
        this.nxJson = nxJson;
        this.legacyRuntimeInputs = legacyRuntimeInputs;
        this.legacyFilesetInputs = legacyFilesetInputs;
        this.projectFileMap = projectFileMap;
        this.allWorkspaceFiles = allWorkspaceFiles;
        this.projectGraph = projectGraph;
        this.fileHasher = fileHasher;
        this.options = options;
        this.filesetHashes = {};
        this.runtimeHashes = {};
        this.externalDependencyHashes = new Map();
        this.projectRootMappings = (0, find_project_for_path_1.createProjectRootMappings)(this.projectGraph.nodes);
        // External Dependencies are all calculated up front in a deterministic order
        this.calculateExternalDependencyHashes();
    }
    hashTask(task, taskGraph, visited) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Promise.resolve().then(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const { selfInputs, depsInputs, depsOutputs, projectInputs } = getInputs(task, this.projectGraph, this.nxJson);
                const selfAndInputs = yield this.hashSelfAndDepsInputs(task.target.project, task, selfInputs, depsInputs, depsOutputs, projectInputs, taskGraph, visited);
                const target = this.hashTarget(task.target.project, task.target.target, selfInputs);
                if (target) {
                    return this.combinePartialHashes([selfAndInputs, target]);
                }
                return selfAndInputs;
            }));
        });
    }
    hashNamedInputForDependencies(projectName, task, namedInput, taskGraph, visited) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const projectNode = this.projectGraph.nodes[projectName];
            const namedInputs = Object.assign(Object.assign({ default: [{ fileset: '{projectRoot}/**/*' }] }, this.nxJson.namedInputs), projectNode.data.namedInputs);
            const expandedInputs = expandNamedInput(namedInput, namedInputs);
            const selfInputs = expandedInputs.filter(isSelfInput);
            const depsOutputs = expandedInputs.filter(isDepsOutput);
            const depsInputs = [{ input: namedInput, dependencies: true }]; // true is boolean by default
            return this.hashSelfAndDepsInputs(projectName, task, selfInputs, depsInputs, depsOutputs, [], taskGraph, visited);
        });
    }
    hashSelfAndDepsInputs(projectName, task, selfInputs, depsInputs, depsOutputs, projectInputs, taskGraph, visited) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const projectGraphDeps = (_a = this.projectGraph.dependencies[projectName]) !== null && _a !== void 0 ? _a : [];
            // we don't want random order of dependencies to change the hash
            projectGraphDeps.sort((a, b) => a.target.localeCompare(b.target));
            const self = yield this.hashSingleProjectInputs(projectName, selfInputs);
            const deps = yield this.hashDepsInputs(task, depsInputs, projectGraphDeps, taskGraph, visited);
            const depsOut = yield this.hashDepsOutputs(task, depsOutputs, taskGraph);
            const projects = yield this.hashProjectInputs(projectInputs);
            return this.combinePartialHashes([
                ...self,
                ...deps,
                ...projects,
                ...depsOut,
            ]);
        });
    }
    combinePartialHashes(partialHashes) {
        if (partialHashes.length === 1) {
            return partialHashes[0];
        }
        const details = {};
        const hashValues = [];
        for (const partial of partialHashes) {
            hashValues.push(partial.value);
            Object.assign(details, partial.details);
        }
        const value = (0, file_hasher_1.hashArray)(hashValues);
        return { value, details };
    }
    hashDepsInputs(task, inputs, projectGraphDeps, taskGraph, visited) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield Promise.all(inputs.map((input) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                return yield Promise.all(projectGraphDeps.map((d) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (visited.indexOf(d.target) > -1) {
                        return null;
                    }
                    else {
                        visited.push(d.target);
                        if (this.projectGraph.nodes[d.target]) {
                            return yield this.hashNamedInputForDependencies(d.target, task, input.input || 'default', taskGraph, visited);
                        }
                        else {
                            return this.getExternalDependencyHash(d.target);
                        }
                    }
                })));
            }))))
                .flat()
                .filter((r) => !!r);
        });
    }
    hashDepsOutputs(task, depsOutputs, taskGraph) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (depsOutputs.length === 0) {
                return [];
            }
            const result = [];
            for (const { dependentTasksOutputFiles, transitive } of depsOutputs) {
                result.push(...(yield this.hashDepOuputs(task, dependentTasksOutputFiles, taskGraph, transitive)));
            }
            return result;
        });
    }
    hashDepOuputs(task, dependentTasksOutputFiles, taskGraph, transitive) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // task has no dependencies
            if (!taskGraph.dependencies[task.id]) {
                return [];
            }
            const partialHashes = [];
            for (const d of taskGraph.dependencies[task.id]) {
                const childTask = taskGraph.tasks[d];
                const outputs = (0, utils_1.getOutputsForTargetAndConfiguration)(childTask, this.projectGraph.nodes[childTask.target.project]);
                const { getFilesForOutputs } = require('../native');
                const outputFiles = getFilesForOutputs(workspace_root_1.workspaceRoot, outputs);
                const filteredFiles = outputFiles.filter((p) => p === dependentTasksOutputFiles ||
                    minimatch(p, dependentTasksOutputFiles, { dot: true }));
                const hashDetails = {};
                const hashes = [];
                for (const [file, hash] of yield this.fileHasher.hashFiles(filteredFiles.map((p) => (0, path_1.join)(workspace_root_1.workspaceRoot, p)))) {
                    hashes.push(hash);
                    hashDetails[(0, path_2.normalizePath)((0, path_1.relative)(workspace_root_1.workspaceRoot, file))] = hash;
                }
                partialHashes.push({
                    value: (0, file_hasher_1.hashArray)(hashes),
                    details: hashDetails,
                });
                if (transitive) {
                    partialHashes.push(...(yield this.hashDepOuputs(childTask, dependentTasksOutputFiles, taskGraph, transitive)));
                }
            }
            return partialHashes;
        });
    }
    getExternalDependencyHash(externalNodeName) {
        const combinedHash = this.combinePartialHashes(this.externalDependencyHashes.get(externalNodeName));
        // Set the combined hash into the hashes so it's not recalculated next time
        this.externalDependencyHashes.set(externalNodeName, [combinedHash]);
        return combinedHash;
    }
    hashSingleExternalDependency(externalNodeName) {
        const node = this.projectGraph.externalNodes[externalNodeName];
        if (node.data.hash) {
            // we already know the hash of this dependency
            return {
                value: node.data.hash,
                details: {
                    [externalNodeName]: node.data.hash,
                },
            };
        }
        else {
            // we take version as a hash
            return {
                value: node.data.version,
                details: {
                    [externalNodeName]: node.data.version,
                },
            };
        }
    }
    hashExternalDependency(externalNodeName) {
        const partialHashes = new Set();
        partialHashes.add(this.hashSingleExternalDependency(externalNodeName));
        const deps = (0, project_graph_utils_1.findAllProjectNodeDependencies)(externalNodeName, this.projectGraph, true);
        for (const dep of deps) {
            partialHashes.add(this.hashSingleExternalDependency(dep));
        }
        return Array.from(partialHashes);
    }
    hashTarget(projectName, targetName, selfInputs) {
        const projectNode = this.projectGraph.nodes[projectName];
        const target = projectNode.data.targets[targetName];
        if (!target) {
            return;
        }
        let hash;
        // we can only vouch for @nx packages's executor dependencies
        // if it's "run commands" or third-party we skip traversing since we have no info what this command depends on
        if (target.executor.startsWith(`@nrwl/`) ||
            target.executor.startsWith(`@nx/`)) {
            const executorPackage = target.executor.split(':')[0];
            const executorNodeName = this.findExternalDependencyNodeName(executorPackage);
            // This is either a local plugin or a non-existent executor
            if (!executorNodeName) {
                // TODO: This should not return null if it is a local plugin's executor
                return null;
            }
            return this.getExternalDependencyHash(executorNodeName);
        }
        else {
            // use command external dependencies if available to construct the hash
            const partialHashes = [];
            let hasCommandExternalDependencies = false;
            for (const input of selfInputs) {
                if (input['externalDependencies']) {
                    // if we have externalDependencies with empty array we still want to override the default hash
                    hasCommandExternalDependencies = true;
                    const externalDependencies = input['externalDependencies'];
                    for (let dep of externalDependencies) {
                        dep = this.findExternalDependencyNodeName(dep);
                        if (!dep) {
                            throw new Error(`The externalDependency "${dep}" for "${projectName}:${targetName}" could not be found`);
                        }
                        partialHashes.push(this.getExternalDependencyHash(dep));
                    }
                }
            }
            if (hasCommandExternalDependencies) {
                return this.combinePartialHashes(partialHashes);
            }
            else {
                // cache the hash of the entire external dependencies tree
                if (this.allExternalDependenciesHash) {
                    return this.allExternalDependenciesHash;
                }
                else {
                    hash = (0, file_hasher_1.hashArray)([JSON.stringify(this.projectGraph.externalNodes)]);
                    this.allExternalDependenciesHash = {
                        value: hash,
                        details: {
                            AllExternalDependencies: hash,
                        },
                    };
                    return this.allExternalDependenciesHash;
                }
            }
        }
    }
    findExternalDependencyNodeName(packageName) {
        if (this.projectGraph.externalNodes[packageName]) {
            return packageName;
        }
        if (this.projectGraph.externalNodes[`npm:${packageName}`]) {
            return `npm:${packageName}`;
        }
        for (const node of Object.values(this.projectGraph.externalNodes)) {
            if (node.data.packageName === packageName) {
                return node.name;
            }
        }
        // not found
        return null;
    }
    hashSingleProjectInputs(projectName, inputs) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const filesets = extractPatternsFromFileSets(inputs);
            const projectFilesets = [];
            const workspaceFilesets = [];
            let invalidFilesetNoPrefix = null;
            let invalidFilesetWorkspaceRootNegative = null;
            for (let f of filesets) {
                if (f.startsWith('{projectRoot}/') || f.startsWith('!{projectRoot}/')) {
                    projectFilesets.push(f);
                }
                else if (f.startsWith('{workspaceRoot}/') ||
                    f.startsWith('!{workspaceRoot}/')) {
                    workspaceFilesets.push(f);
                }
                else {
                    invalidFilesetNoPrefix = f;
                }
            }
            if (invalidFilesetNoPrefix) {
                throw new Error([
                    `"${invalidFilesetNoPrefix}" is an invalid fileset.`,
                    'All filesets have to start with either {workspaceRoot} or {projectRoot}.',
                    'For instance: "!{projectRoot}/**/*.spec.ts" or "{workspaceRoot}/package.json".',
                    `If "${invalidFilesetNoPrefix}" is a named input, make sure it is defined in, for instance, nx.json.`,
                ].join('\n'));
            }
            if (invalidFilesetWorkspaceRootNegative) {
                throw new Error([
                    `"${invalidFilesetWorkspaceRootNegative}" is an invalid fileset.`,
                    'It is not possible to negative filesets starting with {workspaceRoot}.',
                ].join('\n'));
            }
            const notFilesets = inputs.filter((r) => !r['fileset']);
            return Promise.all([
                this.hashProjectFileset(projectName, projectFilesets),
                this.hashProjectConfig(projectName),
                this.hashTsConfig(projectName),
                ...[
                    ...workspaceFilesets,
                    ...this.legacyFilesetInputs.map((r) => r.fileset),
                ].map((fileset) => this.hashRootFileset(fileset)),
                ...[...notFilesets, ...this.legacyRuntimeInputs].map((r) => r['runtime'] ? this.hashRuntime(r['runtime']) : this.hashEnv(r['env'])),
            ]);
        });
    }
    hashProjectInputs(projectInputs) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const partialHashes = [];
            for (const input of projectInputs) {
                const projects = (0, find_matching_projects_1.findMatchingProjects)(input.projects, this.projectGraph.nodes);
                for (const project of projects) {
                    const namedInputs = getNamedInputs(this.nxJson, this.projectGraph.nodes[project]);
                    const expandedInput = expandSingleProjectInputs([{ input: input.input }], namedInputs);
                    partialHashes.push(this.hashSingleProjectInputs(project, expandedInput));
                }
            }
            return Promise.all(partialHashes).then((hashes) => hashes.flat());
        });
    }
    hashRootFileset(fileset) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const mapKey = fileset;
            const withoutWorkspaceRoot = fileset.substring(16);
            if (!this.filesetHashes[mapKey]) {
                this.filesetHashes[mapKey] = new Promise((res) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const parts = [];
                    const matchingFile = this.allWorkspaceFiles.find((t) => t.file === withoutWorkspaceRoot);
                    if (matchingFile) {
                        parts.push(matchingFile.hash);
                    }
                    else {
                        this.allWorkspaceFiles
                            .filter((f) => minimatch(f.file, withoutWorkspaceRoot))
                            .forEach((f) => {
                            parts.push(f.hash);
                        });
                    }
                    const value = (0, file_hasher_1.hashArray)(parts);
                    res({
                        value,
                        details: { [mapKey]: value },
                    });
                }));
            }
            return this.filesetHashes[mapKey];
        });
    }
    hashProjectConfig(projectName) {
        const p = this.projectGraph.nodes[projectName];
        const projectConfig = (0, file_hasher_1.hashArray)([
            JSON.stringify(Object.assign(Object.assign({}, p.data), { files: undefined })),
        ]);
        return {
            value: projectConfig,
            details: {
                ProjectConfiguration: projectConfig,
            },
        };
    }
    hashTsConfig(projectName) {
        const p = this.projectGraph.nodes[projectName];
        const tsConfig = (0, file_hasher_1.hashArray)([
            (0, hasher_1.hashTsConfig)(p, this.projectRootMappings, this.options),
        ]);
        return {
            value: tsConfig,
            details: {
                TsConfig: tsConfig,
            },
        };
    }
    hashProjectFileset(projectName, filesetPatterns) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const mapKey = `${projectName}:${filesetPatterns.join(',')}`;
            if (!this.filesetHashes[mapKey]) {
                this.filesetHashes[mapKey] = new Promise((res) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    const p = this.projectGraph.nodes[projectName];
                    const filteredFiles = filterUsingGlobPatterns(p.data.root, this.projectFileMap[projectName] || [], filesetPatterns);
                    const files = [];
                    for (const { file, hash } of filteredFiles) {
                        files.push(file, hash);
                    }
                    const value = (0, file_hasher_1.hashArray)(files);
                    res({
                        value,
                        details: { [mapKey]: value },
                    });
                }));
            }
            return this.filesetHashes[mapKey];
        });
    }
    hashRuntime(runtime) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const mapKey = `runtime:${runtime}`;
            if (!this.runtimeHashes[mapKey]) {
                this.runtimeHashes[mapKey] = new Promise((res, rej) => {
                    (0, child_process_1.exec)(runtime, {
                        windowsHide: true,
                        cwd: workspace_root_1.workspaceRoot,
                    }, (err, stdout, stderr) => {
                        if (err) {
                            rej(new Error(`Nx failed to execute {runtime: '${runtime}'}. ${err}.`));
                        }
                        else {
                            const value = `${stdout}${stderr}`.trim();
                            res({
                                details: { [`runtime:${runtime}`]: value },
                                value,
                            });
                        }
                    });
                });
            }
            return this.runtimeHashes[mapKey];
        });
    }
    hashEnv(envVarName) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let env = (0, set_hash_env_1.getHashEnv)();
            const value = (0, file_hasher_1.hashArray)([(_a = env[envVarName]) !== null && _a !== void 0 ? _a : '']);
            return {
                details: { [`env:${envVarName}`]: value },
                value,
            };
        });
    }
    calculateExternalDependencyHashes() {
        const keys = Object.keys(this.projectGraph.externalNodes);
        for (const externalNodeName of keys) {
            this.externalDependencyHashes.set(externalNodeName, this.hashExternalDependency(externalNodeName));
        }
    }
}
function getNamedInputs(nxJson, project) {
    return Object.assign(Object.assign({ default: [{ fileset: '{projectRoot}/**/*' }] }, nxJson.namedInputs), project.data.namedInputs);
}
exports.getNamedInputs = getNamedInputs;
function getTargetInputs(nxJson, projectNode, target) {
    const namedInputs = getNamedInputs(nxJson, projectNode);
    const targetData = projectNode.data.targets[target];
    const targetDefaults = (nxJson.targetDefaults || {})[target];
    const inputs = splitInputsIntoSelfAndDependencies(targetData.inputs || (targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults.inputs) || DEFAULT_INPUTS, namedInputs);
    const selfInputs = extractPatternsFromFileSets(inputs.selfInputs);
    const dependencyInputs = extractPatternsFromFileSets(inputs.depsInputs.map((s) => expandNamedInput(s.input, namedInputs)).flat());
    return { selfInputs, dependencyInputs };
}
exports.getTargetInputs = getTargetInputs;
function extractPatternsFromFileSets(inputs) {
    return inputs
        .filter((c) => !!c['fileset'])
        .map((c) => c['fileset']);
}
exports.extractPatternsFromFileSets = extractPatternsFromFileSets;
function getInputs(task, projectGraph, nxJson) {
    const projectNode = projectGraph.nodes[task.target.project];
    const namedInputs = getNamedInputs(nxJson, projectNode);
    const targetData = projectNode.data.targets[task.target.target];
    const targetDefaults = (nxJson.targetDefaults || {})[task.target.target];
    const { selfInputs, depsInputs, depsOutputs, projectInputs } = splitInputsIntoSelfAndDependencies(targetData.inputs || (targetDefaults === null || targetDefaults === void 0 ? void 0 : targetDefaults.inputs) || DEFAULT_INPUTS, namedInputs);
    return { selfInputs, depsInputs, depsOutputs, projectInputs };
}
exports.getInputs = getInputs;
function splitInputsIntoSelfAndDependencies(inputs, namedInputs) {
    const depsInputs = [];
    const projectInputs = [];
    const selfInputs = [];
    for (const d of inputs) {
        if (typeof d === 'string') {
            if (d.startsWith('^')) {
                depsInputs.push({ input: d.substring(1), dependencies: true });
            }
            else {
                selfInputs.push(d);
            }
        }
        else {
            if (('dependencies' in d && d.dependencies) ||
                // Todo(@AgentEnder): Remove check in v17
                ('projects' in d &&
                    typeof d.projects === 'string' &&
                    d.projects === 'dependencies')) {
                depsInputs.push({
                    input: d.input,
                    dependencies: true,
                });
            }
            else if ('projects' in d &&
                d.projects &&
                // Todo(@AgentEnder): Remove check in v17
                !(d.projects === 'self')) {
                projectInputs.push({
                    input: d.input,
                    projects: Array.isArray(d.projects) ? d.projects : [d.projects],
                });
            }
            else {
                selfInputs.push(d);
            }
        }
    }
    const expandedInputs = expandSingleProjectInputs(selfInputs, namedInputs);
    return {
        depsInputs,
        projectInputs,
        selfInputs: expandedInputs.filter(isSelfInput),
        depsOutputs: expandedInputs.filter(isDepsOutput),
    };
}
function isSelfInput(input) {
    return !('dependentTasksOutputFiles' in input);
}
function isDepsOutput(input) {
    return 'dependentTasksOutputFiles' in input;
}
function expandSingleProjectInputs(inputs, namedInputs) {
    const expanded = [];
    for (const d of inputs) {
        if (typeof d === 'string') {
            if (d.startsWith('^'))
                throw new Error(`namedInputs definitions cannot start with ^`);
            if (namedInputs[d]) {
                expanded.push(...expandNamedInput(d, namedInputs));
            }
            else {
                expanded.push({ fileset: d });
            }
        }
        else {
            if (d.projects || d.dependencies) {
                throw new Error(`namedInputs definitions can only refer to other namedInputs definitions within the same project.`);
            }
            if (d.fileset ||
                d.env ||
                d.runtime ||
                d.externalDependencies ||
                d.dependentTasksOutputFiles) {
                expanded.push(d);
            }
            else {
                expanded.push(...expandNamedInput(d.input, namedInputs));
            }
        }
    }
    return expanded;
}
function expandNamedInput(input, namedInputs) {
    namedInputs || (namedInputs = {});
    if (!namedInputs[input])
        throw new Error(`Input '${input}' is not defined`);
    return expandSingleProjectInputs(namedInputs[input], namedInputs);
}
exports.expandNamedInput = expandNamedInput;
function filterUsingGlobPatterns(root, files, patterns) {
    const filesetWithExpandedProjectRoot = patterns
        .map((f) => f.replace('{projectRoot}', root))
        .map((r) => {
        // handling root level projects that create './' pattern that doesn't work with minimatch
        if (r.startsWith('./'))
            return r.substring(2);
        if (r.startsWith('!./'))
            return '!' + r.substring(3);
        return r;
    });
    const positive = [];
    const negative = [];
    for (const p of filesetWithExpandedProjectRoot) {
        if (p.startsWith('!')) {
            negative.push(p);
        }
        else {
            positive.push(p);
        }
    }
    if (positive.length === 0 && negative.length === 0) {
        return files;
    }
    return files.filter((f) => {
        let matchedPositive = false;
        if (positive.length === 0 ||
            (positive.length === 1 && positive[0] === `${root}/**/*`)) {
            matchedPositive = true;
        }
        else {
            matchedPositive = positive.some((pattern) => minimatch(f.file, pattern));
        }
        if (!matchedPositive)
            return false;
        return negative.every((pattern) => minimatch(f.file, pattern));
    });
}
exports.filterUsingGlobPatterns = filterUsingGlobPatterns;
