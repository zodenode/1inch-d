"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.determineProjectNameAndRootOptions = void 0;
const tslib_1 = require("tslib");
const enquirer_1 = require("enquirer");
const nx_1 = require("../../nx");
const get_workspace_layout_1 = require("../utils/get-workspace-layout");
const names_1 = require("../utils/names");
const { joinPathFragments, readJson, readNxJson } = (0, nx_1.requireNx)();
function determineProjectNameAndRootOptions(tree, options) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        validateName(options.name, options.projectNameAndRootFormat);
        const formats = getProjectNameAndRootFormats(tree, options);
        const format = (_a = options.projectNameAndRootFormat) !== null && _a !== void 0 ? _a : (yield determineFormat(formats));
        return formats[format];
    });
}
exports.determineProjectNameAndRootOptions = determineProjectNameAndRootOptions;
function validateName(name, projectNameAndRootFormat) {
    if (projectNameAndRootFormat === 'derived' && name.startsWith('@')) {
        throw new Error(`The project name "${name}" cannot start with "@" when the "projectNameAndRootFormat" is "derived".`);
    }
    /**
     * Matches two types of project names:
     *
     * 1. Valid npm package names (e.g., '@scope/name' or 'name').
     * 2. Names starting with a letter and can contain any character except whitespace and ':'.
     *
     * The second case is to support the legacy behavior (^[a-zA-Z].*$) with the difference
     * that it doesn't allow the ":" character. It was wrong to allow it because it would
     * conflict with the notation for tasks.
     */
    const pattern = '(?:^@[a-zA-Z0-9-*~][a-zA-Z0-9-*._~]*\\/[a-zA-Z0-9-~][a-zA-Z0-9-._~]*|^[a-zA-Z][^:]*)$';
    const validationRegex = new RegExp(pattern);
    if (!validationRegex.test(name)) {
        throw new Error(`The project name should match the pattern "${pattern}". The provided value "${name}" does not match.`);
    }
}
function determineFormat(formats) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (!formats.derived) {
            return 'as-provided';
        }
        if (process.env.NX_INTERACTIVE !== 'true' || !isTTY()) {
            return 'derived';
        }
        const asProvidedDescription = `As provided:
    Name: ${formats['as-provided'].projectName}
    Root: ${formats['as-provided'].projectRoot}`;
        const asProvidedSelectedValue = `${formats['as-provided'].projectName} @ ${formats['as-provided'].projectRoot}`;
        const derivedDescription = `Derived:
    Name: ${formats['derived'].projectName}
    Root: ${formats['derived'].projectRoot}`;
        const derivedSelectedValue = `${formats['derived'].projectName} @ ${formats['derived'].projectRoot} (This was derived from the folder structure. Please provide the exact name and directory in the future)`;
        return yield (0, enquirer_1.prompt)({
            type: 'select',
            name: 'format',
            message: 'What should be the project name and where should it be generated?',
            choices: [
                {
                    message: asProvidedDescription,
                    name: asProvidedSelectedValue,
                },
                {
                    message: derivedDescription,
                    name: derivedSelectedValue,
                },
            ],
            initial: 'as-provided',
        }).then(({ format }) => format === asProvidedSelectedValue ? 'as-provided' : 'derived');
    });
}
function getProjectNameAndRootFormats(tree, options) {
    var _a, _b, _c, _d;
    const name = (0, names_1.names)(options.name).fileName;
    const directory = (_a = options.directory) === null || _a === void 0 ? void 0 : _a.replace(/^\.?\//, '');
    const asProvidedProjectName = name;
    const asProvidedProjectDirectory = directory
        ? (0, names_1.names)(directory).fileName
        : options.rootProject
            ? '.'
            : asProvidedProjectName;
    if (name.startsWith('@')) {
        const nameWithoutScope = asProvidedProjectName.split('/')[1];
        return {
            'as-provided': {
                projectName: asProvidedProjectName,
                names: {
                    projectSimpleName: nameWithoutScope,
                    projectFileName: nameWithoutScope,
                },
                importPath: (_b = options.importPath) !== null && _b !== void 0 ? _b : asProvidedProjectName,
                projectRoot: asProvidedProjectDirectory,
            },
        };
    }
    let asProvidedImportPath;
    let npmScope;
    if (options.projectType === 'library') {
        asProvidedImportPath = options.importPath;
        if (!asProvidedImportPath) {
            npmScope = getNpmScope(tree);
            asProvidedImportPath =
                asProvidedProjectDirectory === '.'
                    ? (_c = readJson(tree, 'package.json').name) !== null && _c !== void 0 ? _c : getImportPath(npmScope, asProvidedProjectName)
                    : getImportPath(npmScope, asProvidedProjectName);
        }
    }
    let { projectDirectory, layoutDirectory } = getDirectories(tree, directory, options.projectType);
    const derivedProjectDirectoryWithoutLayout = projectDirectory
        ? `${(0, names_1.names)(projectDirectory).fileName}/${name}`
        : options.rootProject
            ? '.'
            : name;
    // the project name uses the directory without the layout directory
    const derivedProjectName = derivedProjectDirectoryWithoutLayout === '.'
        ? name
        : derivedProjectDirectoryWithoutLayout.replace(/\//g, '-');
    const derivedSimpleProjectName = name;
    let derivedProjectDirectory = derivedProjectDirectoryWithoutLayout;
    if (derivedProjectDirectoryWithoutLayout !== '.') {
        // prepend the layout directory
        derivedProjectDirectory = joinPathFragments(layoutDirectory, derivedProjectDirectory);
    }
    let derivedImportPath;
    if (options.projectType === 'library') {
        derivedImportPath = options.importPath;
        if (!derivedImportPath) {
            derivedImportPath =
                derivedProjectDirectory === '.'
                    ? (_d = readJson(tree, 'package.json').name) !== null && _d !== void 0 ? _d : getImportPath(npmScope, derivedProjectName)
                    : getImportPath(npmScope, derivedProjectDirectoryWithoutLayout);
        }
    }
    return {
        'as-provided': {
            projectName: asProvidedProjectName,
            names: {
                projectSimpleName: asProvidedProjectName,
                projectFileName: asProvidedProjectName,
            },
            importPath: asProvidedImportPath,
            projectRoot: asProvidedProjectDirectory,
        },
        derived: {
            projectName: derivedProjectName,
            names: {
                projectSimpleName: derivedSimpleProjectName,
                projectFileName: derivedProjectName,
            },
            importPath: derivedImportPath,
            projectRoot: derivedProjectDirectory,
        },
    };
}
function getDirectories(tree, directory, projectType) {
    let { projectDirectory, layoutDirectory } = (0, get_workspace_layout_1.extractLayoutDirectory)(directory);
    if (!layoutDirectory) {
        const { appsDir, libsDir } = (0, get_workspace_layout_1.getWorkspaceLayout)(tree);
        layoutDirectory = projectType === 'application' ? appsDir : libsDir;
    }
    return { projectDirectory, layoutDirectory };
}
function getImportPath(npmScope, name) {
    return npmScope ? `${npmScope === '@' ? '' : '@'}${npmScope}/${name}` : name;
}
function getNpmScope(tree) {
    const nxJson = readNxJson(tree);
    // TODO(v17): Remove reading this from nx.json
    if (nxJson === null || nxJson === void 0 ? void 0 : nxJson.npmScope) {
        return nxJson.npmScope;
    }
    const { name } = tree.exists('package.json')
        ? readJson(tree, 'package.json')
        : { name: null };
    return (name === null || name === void 0 ? void 0 : name.startsWith('@')) ? name.split('/')[0].substring(1) : undefined;
}
function isTTY() {
    return !!process.stdout.isTTY && process.env['CI'] !== 'true';
}
