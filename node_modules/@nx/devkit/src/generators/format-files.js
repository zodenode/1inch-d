"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatFiles = void 0;
const tslib_1 = require("tslib");
const path = require("path");
const nx_1 = require("../../nx");
let { updateJson, readJson, sortObjectByKeys } = (0, nx_1.requireNx)();
// TODO: Remove this in Nx 18 when Nx 16.7.0 is no longer supported
sortObjectByKeys =
    sortObjectByKeys !== null && sortObjectByKeys !== void 0 ? sortObjectByKeys : require('nx/src/utils/object-sort').sortObjectByKeys;
/**
 * Formats all the created or updated files using Prettier
 * @param tree - the file system tree
 */
function formatFiles(tree) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        let prettier;
        try {
            prettier = yield Promise.resolve().then(() => require('prettier'));
        }
        catch (_a) { }
        sortTsConfig(tree);
        if (!prettier)
            return;
        const files = new Set(tree.listChanges().filter((file) => file.type !== 'DELETE'));
        const changedPrettierInTree = getChangedPrettierConfigInTree(tree);
        yield Promise.all(Array.from(files).map((file) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const systemPath = path.join(tree.root, file.path);
                const resolvedOptions = yield prettier.resolveConfig(systemPath, {
                    editorconfig: true,
                });
                const options = Object.assign(Object.assign(Object.assign({}, resolvedOptions), changedPrettierInTree), { filepath: systemPath });
                if (file.path.endsWith('.swcrc')) {
                    options.parser = 'json';
                }
                const support = yield prettier.getFileInfo(systemPath, options);
                if (support.ignored || !support.inferredParser) {
                    return;
                }
                tree.write(file.path, 
                // In prettier v3 the format result is a promise
                yield prettier.format(file.content.toString('utf-8'), options));
            }
            catch (e) {
                console.warn(`Could not format ${file.path}. Error: "${e.message}"`);
            }
        })));
    });
}
exports.formatFiles = formatFiles;
function sortTsConfig(tree) {
    try {
        const tsConfigPath = getRootTsConfigPath(tree);
        if (!tsConfigPath) {
            return;
        }
        updateJson(tree, tsConfigPath, (tsconfig) => (Object.assign(Object.assign({}, tsconfig), { compilerOptions: Object.assign(Object.assign({}, tsconfig.compilerOptions), { paths: sortObjectByKeys(tsconfig.compilerOptions.paths) }) })));
    }
    catch (e) {
        // catch noop
    }
}
function getRootTsConfigPath(tree) {
    for (const path of ['tsconfig.base.json', 'tsconfig.json']) {
        if (tree.exists(path)) {
            return path;
        }
    }
    return null;
}
function getChangedPrettierConfigInTree(tree) {
    if (tree.listChanges().find((file) => file.path === '.prettierrc')) {
        try {
            return readJson(tree, '.prettierrc');
        }
        catch (_a) {
            return null;
        }
    }
    else {
        return null;
    }
}
