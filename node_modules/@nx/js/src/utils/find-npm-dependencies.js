"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findNpmDependencies = void 0;
const path_1 = require("path");
const configuration_1 = require("nx/src/config/configuration");
const task_hasher_1 = require("nx/src/hasher/task-hasher");
const devkit_1 = require("@nx/devkit");
const fileutils_1 = require("nx/src/utils/fileutils");
const project_graph_1 = require("nx/src/config/project-graph");
const ts_config_1 = require("./typescript/ts-config");
/**
 * Finds all npm dependencies and their expected versions for a given project.
 */
function findNpmDependencies(workspaceRoot, sourceProject, projectGraph, projectFileMap, buildTarget, options = {}) {
    let seen = null;
    if (options.includeTransitiveDependencies) {
        seen = new Set();
    }
    const results = {};
    function collectAll(currentProject, collectedDeps) {
        if (seen === null || seen === void 0 ? void 0 : seen.has(currentProject.name))
            return;
        collectDependenciesFromFileMap(workspaceRoot, currentProject, projectGraph, projectFileMap, buildTarget, collectedDeps);
        collectHelperDependencies(workspaceRoot, currentProject, projectGraph, buildTarget, collectedDeps);
        if (options.includeTransitiveDependencies) {
            const projectDeps = projectGraph.dependencies[currentProject.name];
            for (const dep of projectDeps) {
                const projectDep = projectGraph.nodes[dep.target];
                if (projectDep)
                    collectAll(projectDep, collectedDeps);
            }
        }
    }
    collectAll(sourceProject, results);
    return results;
}
exports.findNpmDependencies = findNpmDependencies;
// Keep track of workspace libs we already read package.json for so we don't read from disk again.
const seenWorkspaceDeps = {};
function collectDependenciesFromFileMap(workspaceRoot, sourceProject, projectGraph, projectFileMap, buildTarget, npmDeps) {
    const rawFiles = projectFileMap[sourceProject.name];
    if (!rawFiles)
        return;
    // Cannot read inputs if the target does not exist on the project.
    if (!sourceProject.data.targets[buildTarget])
        return;
    const inputs = (0, task_hasher_1.getTargetInputs)((0, configuration_1.readNxJson)(), sourceProject, buildTarget).selfInputs;
    const files = (0, task_hasher_1.filterUsingGlobPatterns)(sourceProject.data.root, projectFileMap[sourceProject.name] || [], inputs);
    for (const fileData of files) {
        if (!fileData.deps ||
            fileData.file ===
                (0, devkit_1.joinPathFragments)(sourceProject.data.root, 'package.json')) {
            continue;
        }
        for (const dep of fileData.deps) {
            const target = (0, project_graph_1.fileDataDepTarget)(dep);
            // If the node is external, then read package info from `data`.
            const externalDep = projectGraph.externalNodes[target];
            if ((externalDep === null || externalDep === void 0 ? void 0 : externalDep.type) === 'npm') {
                npmDeps[externalDep.data.packageName] = externalDep.data.version;
                continue;
            }
            // If node is internal, then try reading package info from `package.json` (which must exist for this to work).
            const workspaceDep = projectGraph.nodes[target];
            if (!workspaceDep)
                continue;
            const cached = seenWorkspaceDeps[workspaceDep.name];
            if (cached) {
                npmDeps[cached.name] = cached.version;
            }
            else {
                const packageJson = readPackageJson(workspaceDep, workspaceRoot);
                if (packageJson) {
                    // This is a workspace lib so we can't reliably read in a specific version since it depends on how the workspace is set up.
                    // ASSUMPTION: Most users will use '*' for workspace lib versions. Otherwise, they can manually update it.
                    npmDeps[packageJson.name] = '*';
                    seenWorkspaceDeps[workspaceDep.name] = {
                        name: packageJson.name,
                        version: '*',
                    };
                }
            }
        }
    }
}
function readPackageJson(project, workspaceRoot) {
    const packageJsonPath = (0, path_1.join)(workspaceRoot, project.data.root, 'package.json');
    if ((0, fileutils_1.fileExists)(packageJsonPath))
        return (0, devkit_1.readJsonFile)(packageJsonPath);
    return null;
}
function collectHelperDependencies(workspaceRoot, sourceProject, projectGraph, buildTarget, npmDeps) {
    var _a, _b, _c, _d;
    const target = sourceProject.data.targets[buildTarget];
    if (!target)
        return;
    if (target.executor === '@nx/js:tsc' && ((_a = target.options) === null || _a === void 0 ? void 0 : _a.tsConfig)) {
        const tsConfig = (0, ts_config_1.readTsConfig)((0, path_1.join)(workspaceRoot, target.options.tsConfig));
        if (tsConfig === null || tsConfig === void 0 ? void 0 : tsConfig.options['importHelpers']) {
            npmDeps['tslib'] = (_b = projectGraph.externalNodes['npm:tslib']) === null || _b === void 0 ? void 0 : _b.data.version;
        }
    }
    if (target.executor === '@nx/js:swc') {
        const swcConfigPath = target.options.swcrc
            ? (0, path_1.join)(workspaceRoot, target.options.swcrc)
            : (0, path_1.join)(workspaceRoot, sourceProject.data.root, '.swcrc');
        const swcConfig = (0, fileutils_1.fileExists)(swcConfigPath)
            ? (0, devkit_1.readJsonFile)(swcConfigPath)
            : {};
        if ((_c = swcConfig === null || swcConfig === void 0 ? void 0 : swcConfig.jsc) === null || _c === void 0 ? void 0 : _c.externalHelpers) {
            npmDeps['@swc/helpers'] =
                (_d = projectGraph.externalNodes['npm:@swc/helpers']) === null || _d === void 0 ? void 0 : _d.data.version;
        }
    }
}
