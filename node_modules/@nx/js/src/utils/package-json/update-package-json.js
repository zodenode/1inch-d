"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUpdatedPackageJsonContent = exports.getExports = exports.updatePackageJson = void 0;
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
const lock_file_1 = require("nx/src/plugins/js/lock-file/lock-file");
// eslint-disable-next-line @typescript-eslint/no-restricted-imports
const create_package_json_1 = require("nx/src/plugins/js/package-json/create-package-json");
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const operators_1 = require("nx/src/project-graph/operators");
const fileutils_1 = require("nx/src/utils/fileutils");
const fs_1 = require("fs");
const nx_deps_cache_1 = require("nx/src/project-graph/nx-deps-cache");
const get_main_file_dir_1 = require("../get-main-file-dir");
function updatePackageJson(options, context, target, dependencies, fileMap = null) {
    var _a;
    let packageJson;
    if (fileMap == null) {
        fileMap = ((_a = (0, nx_deps_cache_1.readProjectFileMapCache)()) === null || _a === void 0 ? void 0 : _a.projectFileMap) || {};
    }
    if (options.updateBuildableProjectDepsInPackageJson) {
        packageJson = (0, create_package_json_1.createPackageJson)(context.projectName, context.projectGraph, {
            target: context.targetName,
            root: context.root,
            // By default we remove devDependencies since this is a production build.
            isProduction: true,
        }, fileMap);
        if (options.excludeLibsInPackageJson) {
            dependencies = dependencies.filter((dep) => dep.node.type !== 'lib');
        }
        addMissingDependencies(packageJson, context, dependencies, options.buildableProjectDepsInPackageJsonType);
    }
    else {
        const pathToPackageJson = (0, path_1.join)(context.root, options.projectRoot, 'package.json');
        packageJson = (0, fileutils_1.fileExists)(pathToPackageJson)
            ? (0, devkit_1.readJsonFile)(pathToPackageJson)
            : { name: context.projectName, version: '0.0.1' };
    }
    // update package specific settings
    packageJson = getUpdatedPackageJsonContent(packageJson, options);
    // save files
    (0, devkit_1.writeJsonFile)(`${options.outputPath}/package.json`, packageJson);
    if (options.generateLockfile) {
        const lockFile = (0, lock_file_1.createLockFile)(packageJson);
        (0, fs_extra_1.writeFileSync)(`${options.outputPath}/${(0, lock_file_1.getLockFileName)()}`, lockFile, {
            encoding: 'utf-8',
        });
    }
}
exports.updatePackageJson = updatePackageJson;
function addMissingDependencies(packageJson, { projectName, targetName, configurationName, root }, dependencies, propType = 'dependencies') {
    const workspacePackageJson = (0, devkit_1.readJsonFile)((0, devkit_1.joinPathFragments)(devkit_1.workspaceRoot, 'package.json'));
    dependencies.forEach((entry) => {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if ((0, operators_1.isNpmProject)(entry.node)) {
            const { packageName, version } = entry.node.data;
            if (((_a = packageJson.dependencies) === null || _a === void 0 ? void 0 : _a[packageName]) ||
                ((_b = packageJson.devDependencies) === null || _b === void 0 ? void 0 : _b[packageName]) ||
                ((_c = packageJson.peerDependencies) === null || _c === void 0 ? void 0 : _c[packageName])) {
                return;
            }
            if ((_d = workspacePackageJson.devDependencies) === null || _d === void 0 ? void 0 : _d[packageName]) {
                return;
            }
            (_e = packageJson[propType]) !== null && _e !== void 0 ? _e : (packageJson[propType] = {});
            packageJson[propType][packageName] = version;
        }
        else {
            const packageName = entry.name;
            if (!((_f = packageJson.dependencies) === null || _f === void 0 ? void 0 : _f[packageName]) &&
                !((_g = packageJson.peerDependencies) === null || _g === void 0 ? void 0 : _g[packageName])) {
                const outputs = (0, devkit_1.getOutputsForTargetAndConfiguration)({
                    overrides: {},
                    target: {
                        project: projectName,
                        target: targetName,
                        configuration: configurationName,
                    },
                }, entry.node);
                const depPackageJsonPath = (0, path_1.join)(root, outputs[0], 'package.json');
                if ((0, fs_1.existsSync)(depPackageJsonPath)) {
                    const version = (0, devkit_1.readJsonFile)(depPackageJsonPath).version;
                    (_h = packageJson[propType]) !== null && _h !== void 0 ? _h : (packageJson[propType] = {});
                    packageJson[propType][packageName] = version;
                }
            }
        }
    });
}
function getExports(options) {
    const mainFile = options.outputFileName
        ? options.outputFileName.replace(/\.[tj]s$/, '')
        : (0, path_1.basename)(options.main).replace(/\.[tj]s$/, '');
    const relativeMainFileDir = options.outputFileName
        ? './'
        : (0, get_main_file_dir_1.getRelativeDirectoryToProjectRoot)(options.main, options.projectRoot);
    const exports = {
        '.': relativeMainFileDir + mainFile + options.fileExt,
    };
    if (options.additionalEntryPoints) {
        const jsRegex = /\.[jt]sx?$/;
        for (const file of options.additionalEntryPoints) {
            const { ext: fileExt, name: fileName } = (0, path_1.parse)(file);
            const relativeDir = (0, get_main_file_dir_1.getRelativeDirectoryToProjectRoot)(file, options.projectRoot);
            const sourceFilePath = relativeDir + fileName;
            const entryFilepath = sourceFilePath.replace(/^\.\/src\//, './');
            const isJsFile = jsRegex.test(fileExt);
            exports[isJsFile ? entryFilepath : entryFilepath + fileExt] =
                sourceFilePath + (isJsFile ? options.fileExt : fileExt);
        }
    }
    return exports;
}
exports.getExports = getExports;
function getUpdatedPackageJsonContent(packageJson, options) {
    var _a, _b, _c, _d, _e, _f, _g;
    var _h;
    // Default is CJS unless esm is explicitly passed.
    const hasCjsFormat = !options.format || ((_a = options.format) === null || _a === void 0 ? void 0 : _a.includes('cjs'));
    const hasEsmFormat = (_b = options.format) === null || _b === void 0 ? void 0 : _b.includes('esm');
    if (options.generateExportsField) {
        packageJson.exports =
            typeof packageJson.exports === 'string' ? {} : Object.assign({}, packageJson.exports);
        packageJson.exports['./package.json'] = './package.json';
    }
    if (hasEsmFormat) {
        const esmExports = getExports(Object.assign(Object.assign({}, options), { fileExt: (_c = options.outputFileExtensionForEsm) !== null && _c !== void 0 ? _c : '.js' }));
        packageJson.module = esmExports['.'];
        if (!hasCjsFormat) {
            packageJson.type = 'module';
            (_d = packageJson.main) !== null && _d !== void 0 ? _d : (packageJson.main = esmExports['.']);
        }
        if (options.generateExportsField) {
            for (const [exportEntry, filePath] of Object.entries(esmExports)) {
                packageJson.exports[exportEntry] = hasCjsFormat
                    ? { import: filePath }
                    : filePath;
            }
        }
    }
    // CJS output may have .cjs or .js file extensions.
    // Bundlers like rollup and esbuild supports .cjs for CJS and .js for ESM.
    // Bundlers/Compilers like webpack, tsc, swc do not have different file extensions (unless you use .mts or .cts in source).
    if (hasCjsFormat) {
        const cjsExports = getExports(Object.assign(Object.assign({}, options), { fileExt: (_e = options.outputFileExtensionForCjs) !== null && _e !== void 0 ? _e : '.js' }));
        packageJson.main = cjsExports['.'];
        if (!hasEsmFormat) {
            packageJson.type = 'commonjs';
        }
        if (options.generateExportsField) {
            for (const [exportEntry, filePath] of Object.entries(cjsExports)) {
                if (hasEsmFormat) {
                    (_f = (_h = packageJson.exports[exportEntry])['default']) !== null && _f !== void 0 ? _f : (_h['default'] = filePath);
                }
                else {
                    packageJson.exports[exportEntry] = filePath;
                }
            }
        }
    }
    if (!options.skipTypings) {
        const mainFile = (0, path_1.basename)(options.main).replace(/\.[tj]s$/, '');
        const relativeMainFileDir = (0, get_main_file_dir_1.getRelativeDirectoryToProjectRoot)(options.main, options.projectRoot);
        const typingsFile = `${relativeMainFileDir}${mainFile}.d.ts`;
        packageJson.types = (_g = packageJson.types) !== null && _g !== void 0 ? _g : typingsFile;
    }
    return packageJson;
}
exports.getUpdatedPackageJsonContent = getUpdatedPackageJsonContent;
