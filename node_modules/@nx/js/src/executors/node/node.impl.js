"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeExecutor = void 0;
const tslib_1 = require("tslib");
const chalk = require("chalk");
const child_process_1 = require("child_process");
const devkit_1 = require("@nx/devkit");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
const client_1 = require("nx/src/daemon/client/client");
const crypto_1 = require("crypto");
const path = require("path");
const path_1 = require("path");
const buildable_libs_utils_1 = require("../../utils/buildable-libs-utils");
const kill_tree_1 = require("./lib/kill-tree");
const fileutils_1 = require("nx/src/utils/fileutils");
const get_main_file_dir_1 = require("../../utils/get-main-file-dir");
function debounce(fn, wait) {
    let timeoutId;
    return () => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(fn, wait);
    };
}
function nodeExecutor(options, context) {
    var _a, _b, _c;
    var _d;
    return tslib_1.__asyncGenerator(this, arguments, function* nodeExecutor_1() {
        (_a = (_d = process.env).NODE_ENV) !== null && _a !== void 0 ? _a : (_d.NODE_ENV = (_b = context === null || context === void 0 ? void 0 : context.configurationName) !== null && _b !== void 0 ? _b : 'development');
        const project = context.projectGraph.nodes[context.projectName];
        const buildTarget = (0, devkit_1.parseTargetString)(options.buildTarget, context.projectGraph);
        if (!project.data.targets[buildTarget.target]) {
            throw new Error(`Cannot find build target ${chalk.bold(options.buildTarget)} for project ${chalk.bold(context.projectName)}`);
        }
        const buildTargetExecutor = (_c = project.data.targets[buildTarget.target]) === null || _c === void 0 ? void 0 : _c.executor;
        if (buildTargetExecutor === 'nx:run-commands' ||
            buildTargetExecutor === '@nrwl/workspace:run-commands') {
            // Run commands does not emit build event, so we have to switch to run entire build through Nx CLI.
            options.runBuildTargetDependencies = true;
        }
        const buildOptions = Object.assign(Object.assign({}, (0, devkit_1.readTargetOptions)(buildTarget, context)), options.buildTargetOptions);
        if (options.waitUntilTargets && options.waitUntilTargets.length > 0) {
            const results = yield tslib_1.__await(runWaitUntilTargets(options, context));
            for (const [i, result] of results.entries()) {
                if (!result.success) {
                    throw new Error(`Wait until target failed: ${options.waitUntilTargets[i]}.`);
                }
            }
        }
        // Re-map buildable workspace projects to their output directory.
        const mappings = calculateResolveMappings(context, options);
        const fileToRun = getFileToRun(context, project, buildOptions, buildTargetExecutor);
        let additionalExitHandler = null;
        let currentTask = null;
        const tasks = [];
        yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues((0, async_iterable_1.createAsyncIterable)(({ done, next, error }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            var _e;
            const processQueue = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                if (tasks.length === 0)
                    return;
                const previousTask = currentTask;
                const task = tasks.shift();
                currentTask = task;
                yield (previousTask === null || previousTask === void 0 ? void 0 : previousTask.stop('SIGTERM'));
                yield task.start();
            });
            const debouncedProcessQueue = debounce(processQueue, (_e = options.debounce) !== null && _e !== void 0 ? _e : 1000);
            const addToQueue = (childProcess, buildResult) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const task = {
                    id: (0, crypto_1.randomUUID)(),
                    killed: false,
                    childProcess,
                    promise: null,
                    start: () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        // Wait for build to finish.
                        const result = yield buildResult;
                        if (!result.success) {
                            // If in watch-mode, don't throw or else the process exits.
                            if (options.watch) {
                                if (!task.killed) {
                                    // Only log build error if task was not killed by a new change.
                                    devkit_1.logger.error(`Build failed, waiting for changes to restart...`);
                                }
                                return;
                            }
                            else {
                                throw new Error(`Build failed. See above for errors.`);
                            }
                        }
                        // Before running the program, check if the task has been killed (by a new change during watch).
                        if (task.killed)
                            return;
                        // Run the program
                        task.promise = new Promise((resolve, reject) => {
                            var _a;
                            task.childProcess = (0, child_process_1.fork)((0, devkit_1.joinPathFragments)(__dirname, 'node-with-require-overrides'), (_a = options.args) !== null && _a !== void 0 ? _a : [], {
                                execArgv: getExecArgv(options),
                                stdio: [0, 1, 'pipe', 'ipc'],
                                env: Object.assign(Object.assign({}, process.env), { NX_FILE_TO_RUN: fileToRunCorrectPath(fileToRun), NX_MAPPINGS: JSON.stringify(mappings) }),
                            });
                            const handleStdErr = (data) => {
                                // Don't log out error if task is killed and new one has started.
                                // This could happen if a new build is triggered while new process is starting, since the operation is not atomic.
                                // Log the error in normal mode
                                if (!options.watch || !task.killed) {
                                    devkit_1.logger.error(data.toString());
                                }
                            };
                            task.childProcess.stderr.on('data', handleStdErr);
                            task.childProcess.once('exit', (code) => {
                                task.childProcess.off('data', handleStdErr);
                                if (options.watch && !task.killed) {
                                    devkit_1.logger.info(`NX Process exited with code ${code}, waiting for changes to restart...`);
                                }
                                if (!options.watch)
                                    done();
                                resolve();
                            });
                            next({ success: true, options: buildOptions });
                        });
                    }),
                    stop: (signal = 'SIGTERM') => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        task.killed = true;
                        // Request termination and wait for process to finish gracefully.
                        // NOTE: `childProcess` may not have been set yet if the task did not have a chance to start.
                        // e.g. multiple file change events in a short time (like git checkout).
                        if (task.childProcess) {
                            yield (0, kill_tree_1.killTree)(task.childProcess.pid, signal);
                        }
                        try {
                            yield task.promise;
                        }
                        catch (_f) {
                            // Doesn't matter if task fails, we just need to wait until it finishes.
                        }
                    }),
                };
                tasks.push(task);
            });
            if (options.runBuildTargetDependencies) {
                // If a all dependencies need to be rebuild on changes, then register with watcher
                // and run through CLI, otherwise only the current project will rebuild.
                const runBuild = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    let childProcess = null;
                    const whenReady = new Promise((resolve) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        childProcess = (0, child_process_1.fork)(require.resolve('nx'), [
                            'run',
                            `${context.projectName}:${buildTarget.target}${buildTarget.configuration ? `:${buildTarget.configuration}` : ''}`,
                        ], {
                            cwd: context.root,
                            stdio: 'inherit',
                        });
                        childProcess.once('exit', (code) => {
                            if (code === 0)
                                resolve({ success: true });
                            // If process is killed due to current task being killed, then resolve with success.
                            else
                                resolve({ success: !!(currentTask === null || currentTask === void 0 ? void 0 : currentTask.killed) });
                        });
                    }));
                    yield addToQueue(childProcess, whenReady);
                    yield debouncedProcessQueue();
                });
                additionalExitHandler = yield client_1.daemonClient.registerFileWatcher({
                    watchProjects: [context.projectName],
                    includeDependentProjects: true,
                }, (err, data) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    var _g;
                    if (err === 'closed') {
                        devkit_1.logger.error(`Watch error: Daemon closed the connection`);
                        process.exit(1);
                    }
                    else if (err) {
                        devkit_1.logger.error(`Watch error: ${(_g = err === null || err === void 0 ? void 0 : err.message) !== null && _g !== void 0 ? _g : 'Unknown'}`);
                    }
                    else {
                        devkit_1.logger.info(`NX File change detected. Restarting...`);
                        yield runBuild();
                    }
                }));
                yield runBuild(); // run first build
            }
            else {
                // Otherwise, run the build executor, which will not run task dependencies.
                // This is mostly fine for bundlers like webpack that should already watch for dependency libs.
                // For tsc/swc or custom build commands, consider using `runBuildTargetDependencies` instead.
                const output = yield (0, devkit_1.runExecutor)(buildTarget, Object.assign(Object.assign({}, options.buildTargetOptions), { watch: options.watch }), context);
                while (true) {
                    const event = yield output.next();
                    yield addToQueue(null, Promise.resolve(event.value));
                    yield debouncedProcessQueue();
                    if (event.done || !options.watch) {
                        break;
                    }
                }
            }
            const stopAllTasks = (signal = 'SIGTERM') => {
                additionalExitHandler === null || additionalExitHandler === void 0 ? void 0 : additionalExitHandler();
                for (const task of tasks) {
                    task.stop(signal);
                }
            };
            process.on('SIGTERM', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                stopAllTasks('SIGTERM');
                process.exit(128 + 15);
            }));
            process.on('SIGINT', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                stopAllTasks('SIGINT');
                process.exit(128 + 2);
            }));
            process.on('SIGHUP', () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                stopAllTasks('SIGHUP');
                process.exit(128 + 1);
            }));
        })))));
    });
}
exports.nodeExecutor = nodeExecutor;
function getExecArgv(options) {
    var _a;
    const args = ((_a = options.runtimeArgs) !== null && _a !== void 0 ? _a : (options.runtimeArgs = []));
    args.push('-r', require.resolve('source-map-support/register'));
    if (options.inspect === true) {
        options.inspect = "inspect" /* InspectType.Inspect */;
    }
    if (options.inspect) {
        args.push(`--${options.inspect}=${options.host}:${options.port}`);
    }
    return args;
}
function calculateResolveMappings(context, options) {
    const parsed = (0, devkit_1.parseTargetString)(options.buildTarget, context.projectGraph);
    const { dependencies } = (0, buildable_libs_utils_1.calculateProjectBuildableDependencies)(context.taskGraph, context.projectGraph, context.root, parsed.project, parsed.target, parsed.configuration);
    return dependencies.reduce((m, c) => {
        if (c.node.type !== 'npm' && c.outputs[0] != null) {
            m[c.name] = (0, devkit_1.joinPathFragments)(context.root, c.outputs[0]);
        }
        return m;
    }, {});
}
function runWaitUntilTargets(options, context) {
    return Promise.all(options.waitUntilTargets.map((waitUntilTarget) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const target = (0, devkit_1.parseTargetString)(waitUntilTarget, context.projectGraph);
        const output = yield (0, devkit_1.runExecutor)(target, {}, context);
        return new Promise((resolve) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            let event = yield output.next();
            // Resolve after first event
            resolve(event.value);
            // Continue iterating
            while (!event.done) {
                event = yield output.next();
            }
        }));
    })));
}
function getFileToRun(context, project, buildOptions, buildTargetExecutor) {
    // If using run-commands or another custom executor, then user should set
    // outputFileName, but we can try the default value that we use.
    if (!(buildOptions === null || buildOptions === void 0 ? void 0 : buildOptions.outputPath) && !(buildOptions === null || buildOptions === void 0 ? void 0 : buildOptions.outputFileName)) {
        const fallbackFile = path.join('dist', project.data.root, 'main.js');
        devkit_1.logger.warn(`Build option ${chalk.bold('outputFileName')} not set for ${chalk.bold(project.name)}. Using fallback value of ${chalk.bold(fallbackFile)}.`);
        return (0, path_1.join)(context.root, fallbackFile);
    }
    let outputFileName = buildOptions.outputFileName;
    if (!outputFileName) {
        const fileName = `${path.parse(buildOptions.main).name}.js`;
        if (buildTargetExecutor === '@nx/js:tsc' ||
            buildTargetExecutor === '@nx/js:swc') {
            outputFileName = path.join((0, get_main_file_dir_1.getRelativeDirectoryToProjectRoot)(buildOptions.main, project.data.root), fileName);
        }
        else {
            outputFileName = fileName;
        }
    }
    return (0, path_1.join)(context.root, buildOptions.outputPath, outputFileName);
}
function fileToRunCorrectPath(fileToRun) {
    if ((0, fileutils_1.fileExists)(fileToRun))
        return fileToRun;
    const extensionsToTry = ['.cjs', '.mjs', 'cjs.js', '.esm.js'];
    for (const ext of extensionsToTry) {
        const file = fileToRun.replace(/\.js$/, ext);
        if ((0, fileutils_1.fileExists)(file))
            return file;
    }
    throw new Error(`Could not find ${fileToRun}. Make sure your build succeeded.`);
}
exports.default = nodeExecutor;
