"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEntryPoints = exports.tscExecutor = exports.createTypeScriptCompilationOptions = exports.determineModuleFormatFromTsConfig = void 0;
const tslib_1 = require("tslib");
const ts = require("typescript");
const fast_glob_1 = require("fast-glob");
const copy_assets_handler_1 = require("../../utils/assets/copy-assets-handler");
const check_dependencies_1 = require("../../utils/check-dependencies");
const compiler_helper_dependency_1 = require("../../utils/compiler-helper-dependency");
const inline_1 = require("../../utils/inline");
const update_package_json_1 = require("../../utils/package-json/update-package-json");
const compile_typescript_files_1 = require("../../utils/typescript/compile-typescript-files");
const watch_for_single_file_changes_1 = require("../../utils/watch-for-single-file-changes");
const lib_1 = require("./lib");
const ts_config_1 = require("../../utils/typescript/ts-config");
function determineModuleFormatFromTsConfig(absolutePathToTsConfig) {
    const tsConfig = (0, ts_config_1.readTsConfig)(absolutePathToTsConfig);
    if (tsConfig.options.module === ts.ModuleKind.ES2015 ||
        tsConfig.options.module === ts.ModuleKind.ES2020 ||
        tsConfig.options.module === ts.ModuleKind.ES2022 ||
        tsConfig.options.module === ts.ModuleKind.ESNext) {
        return 'esm';
    }
    else {
        return 'cjs';
    }
}
exports.determineModuleFormatFromTsConfig = determineModuleFormatFromTsConfig;
function createTypeScriptCompilationOptions(normalizedOptions, context) {
    return {
        outputPath: normalizedOptions.outputPath,
        projectName: context.projectName,
        projectRoot: normalizedOptions.projectRoot,
        rootDir: normalizedOptions.rootDir,
        tsConfig: normalizedOptions.tsConfig,
        watch: normalizedOptions.watch,
        deleteOutputPath: normalizedOptions.clean,
        getCustomTransformers: (0, lib_1.getCustomTrasformersFactory)(normalizedOptions.transformers),
    };
}
exports.createTypeScriptCompilationOptions = createTypeScriptCompilationOptions;
function tscExecutor(_options, context) {
    return tslib_1.__asyncGenerator(this, arguments, function* tscExecutor_1() {
        const { sourceRoot, root } = context.projectsConfigurations.projects[context.projectName];
        const options = (0, lib_1.normalizeOptions)(_options, context.root, sourceRoot, root);
        const { projectRoot, tmpTsConfig, target, dependencies } = (0, check_dependencies_1.checkDependencies)(context, _options.tsConfig);
        if (tmpTsConfig) {
            options.tsConfig = tmpTsConfig;
        }
        const tsLibDependency = (0, compiler_helper_dependency_1.getHelperDependency)(compiler_helper_dependency_1.HelperDependency.tsc, options.tsConfig, dependencies, context.projectGraph);
        if (tsLibDependency) {
            dependencies.push(tsLibDependency);
        }
        const assetHandler = new copy_assets_handler_1.CopyAssetsHandler({
            projectDir: projectRoot,
            rootDir: context.root,
            outputDir: _options.outputPath,
            assets: _options.assets,
        });
        const tsCompilationOptions = createTypeScriptCompilationOptions(options, context);
        const inlineProjectGraph = (0, inline_1.handleInliningBuild)(context, options, tsCompilationOptions.tsConfig);
        if (!(0, inline_1.isInlineGraphEmpty)(inlineProjectGraph)) {
            tsCompilationOptions.rootDir = '.';
        }
        const typescriptCompilation = (0, compile_typescript_files_1.compileTypeScriptFiles)(options, tsCompilationOptions, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield assetHandler.processAllAssetsOnce();
            (0, update_package_json_1.updatePackageJson)(Object.assign(Object.assign({}, options), { additionalEntryPoints: createEntryPoints(options, context), format: [determineModuleFormatFromTsConfig(options.tsConfig)], 
                // As long as d.ts files match their .js counterparts, we don't need to emit them.
                // TSC can match them correctly based on file names.
                skipTypings: true }), context, target, dependencies);
            (0, inline_1.postProcessInlinedDependencies)(tsCompilationOptions.outputPath, tsCompilationOptions.projectRoot, inlineProjectGraph);
        }));
        if (options.watch) {
            const disposeWatchAssetChanges = yield tslib_1.__await(assetHandler.watchAndProcessOnAssetChange());
            const disposePackageJsonChanges = yield tslib_1.__await((0, watch_for_single_file_changes_1.watchForSingleFileChanges)(context.projectName, options.projectRoot, 'package.json', () => (0, update_package_json_1.updatePackageJson)(Object.assign(Object.assign({}, options), { additionalEntryPoints: createEntryPoints(options, context), 
                // As long as d.ts files match their .js counterparts, we don't need to emit them.
                // TSC can match them correctly based on file names.
                skipTypings: true, format: [determineModuleFormatFromTsConfig(options.tsConfig)] }), context, target, dependencies)));
            const handleTermination = (exitCode) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield typescriptCompilation.close();
                disposeWatchAssetChanges();
                disposePackageJsonChanges();
                process.exit(exitCode);
            });
            process.on('SIGINT', () => handleTermination(128 + 2));
            process.on('SIGTERM', () => handleTermination(128 + 15));
        }
        return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues(typescriptCompilation.iterator))));
    });
}
exports.tscExecutor = tscExecutor;
function createEntryPoints(options, context) {
    var _a;
    if (!((_a = options.additionalEntryPoints) === null || _a === void 0 ? void 0 : _a.length))
        return [];
    return (0, fast_glob_1.sync)(options.additionalEntryPoints, {
        cwd: context.root,
    });
}
exports.createEntryPoints = createEntryPoints;
exports.default = tscExecutor;
