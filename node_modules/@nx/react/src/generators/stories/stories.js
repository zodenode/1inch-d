"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storiesSchematic = exports.storiesGenerator = exports.createAllStories = exports.containsComponentDeclaration = exports.projectRootPath = void 0;
const tslib_1 = require("tslib");
const component_story_1 = require("../component-story/component-story");
const component_cypress_spec_1 = require("../component-cypress-spec/component-cypress-spec");
const ast_utils_1 = require("../../utils/ast-utils");
const devkit_1 = require("@nx/devkit");
const path_1 = require("path");
const minimatch = require("minimatch");
const ensure_typescript_1 = require("@nx/js/src/utils/typescript/ensure-typescript");
const versions_1 = require("../../utils/versions");
let tsModule;
function projectRootPath(tree, config) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { findStorybookAndBuildTargetsAndCompiler } = yield Promise.resolve().then(() => require('@nx/storybook/src/utils/utilities'));
        let projectDir;
        if (config.projectType === 'application') {
            const { nextBuildTarget } = findStorybookAndBuildTargetsAndCompiler(config.targets);
            if (!!nextBuildTarget) {
                // Next.js apps
                projectDir = 'components';
            }
            else {
                // apps/test-app/src/app
                projectDir = 'app';
            }
        }
        else if (config.projectType == 'library') {
            // libs/test-lib/src/lib
            projectDir = 'lib';
        }
        return (0, devkit_1.joinPathFragments)(config.sourceRoot, projectDir);
    });
}
exports.projectRootPath = projectRootPath;
function containsComponentDeclaration(tree, componentPath) {
    var _a;
    if (!tsModule) {
        tsModule = (0, ensure_typescript_1.ensureTypescript)();
    }
    const contents = tree.read(componentPath, 'utf-8');
    if (contents === null) {
        throw new Error(`Failed to read ${componentPath}`);
    }
    const sourceFile = tsModule.createSourceFile(componentPath, contents, tsModule.ScriptTarget.Latest, true);
    return !!((0, ast_utils_1.getComponentNode)(sourceFile) ||
        ((_a = (0, ast_utils_1.findExportDeclarationsForJsx)(sourceFile)) === null || _a === void 0 ? void 0 : _a.length));
}
exports.containsComponentDeclaration = containsComponentDeclaration;
function createAllStories(tree, projectName, interactionTests, js, projects, projectConfiguration, generateCypressSpecs, cypressProject, ignorePaths) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { isTheFileAStory } = yield Promise.resolve().then(() => require('@nx/storybook/src/utils/utilities'));
        const { sourceRoot, root } = projectConfiguration;
        let componentPaths = [];
        const projectPath = yield projectRootPath(tree, projectConfiguration);
        (0, devkit_1.visitNotIgnoredFiles)(tree, projectPath, (path) => {
            // Ignore private files starting with "_".
            if ((0, path_1.basename)(path).startsWith('_'))
                return;
            if (ignorePaths === null || ignorePaths === void 0 ? void 0 : ignorePaths.some((pattern) => minimatch(path, pattern)))
                return;
            if ((path.endsWith('.tsx') && !path.endsWith('.spec.tsx')) ||
                (path.endsWith('.js') && !path.endsWith('.spec.js')) ||
                (path.endsWith('.jsx') && !path.endsWith('.spec.jsx'))) {
                // Check if file is NOT a story (either ts/tsx or js/jsx)
                if (!isTheFileAStory(tree, path)) {
                    // Since the file is not a story
                    // Let's see if the .stories.* file exists
                    const ext = path.slice(path.lastIndexOf('.'));
                    const storyPath = `${path.split(ext)[0]}.stories${ext}`;
                    if (!tree.exists(storyPath)) {
                        componentPaths.push(path);
                    }
                }
            }
        });
        const e2eProjectName = cypressProject || `${projectName}-e2e`;
        const e2eProject = projects.get(e2eProjectName);
        if (generateCypressSpecs && !e2eProject) {
            devkit_1.logger.info(`There was no e2e project "${e2eProjectName}" found, so cypress specs will not be generated. Pass "--cypressProject" to specify a different e2e project name`);
        }
        yield Promise.all(componentPaths.map((componentPath) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const relativeCmpDir = componentPath.replace((0, path_1.join)(sourceRoot, '/'), '');
            if (!containsComponentDeclaration(tree, componentPath)) {
                return;
            }
            yield (0, component_story_1.default)(tree, {
                componentPath: relativeCmpDir,
                project: projectName,
                skipFormat: true,
                interactionTests,
            });
            if (generateCypressSpecs && e2eProject) {
                yield (0, component_cypress_spec_1.default)(tree, {
                    project: projectName,
                    componentPath: relativeCmpDir,
                    js,
                    cypressProject,
                    skipFormat: true,
                });
            }
        })));
    });
}
exports.createAllStories = createAllStories;
function storiesGenerator(host, schema) {
    var _a;
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const projects = (0, devkit_1.getProjects)(host);
        const projectConfiguration = projects.get(schema.project);
        schema.interactionTests = (_a = schema.interactionTests) !== null && _a !== void 0 ? _a : true;
        yield createAllStories(host, schema.project, schema.interactionTests, schema.js, projects, projectConfiguration, schema.generateCypressSpecs, schema.cypressProject, schema.ignorePaths);
        const tasks = [];
        if (schema.interactionTests) {
            const { interactionTestsDependencies, addInteractionsInAddons } = (0, devkit_1.ensurePackage)('@nx/storybook', versions_1.nxVersion);
            tasks.push((0, devkit_1.addDependenciesToPackageJson)(host, {}, interactionTestsDependencies()));
            addInteractionsInAddons(host, projectConfiguration);
        }
        if (!schema.skipFormat) {
            yield (0, devkit_1.formatFiles)(host);
        }
        return (0, devkit_1.runTasksInSerial)(...tasks);
    });
}
exports.storiesGenerator = storiesGenerator;
exports.default = storiesGenerator;
exports.storiesSchematic = (0, devkit_1.convertNxGenerator)(storiesGenerator);
