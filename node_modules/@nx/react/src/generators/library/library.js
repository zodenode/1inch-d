"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.librarySchematic = exports.libraryGenerator = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const js_1 = require("@nx/js");
const versions_1 = require("../../utils/versions");
const component_1 = require("../component/component");
const init_1 = require("../init/init");
const jest_utils_1 = require("../../utils/jest-utils");
const normalize_options_1 = require("./lib/normalize-options");
const add_rollup_build_target_1 = require("./lib/add-rollup-build-target");
const add_linting_1 = require("./lib/add-linting");
const update_app_routes_1 = require("./lib/update-app-routes");
const create_files_1 = require("./lib/create-files");
const create_ts_config_1 = require("../../utils/create-ts-config");
const install_common_dependencies_1 = require("./lib/install-common-dependencies");
const set_defaults_1 = require("./lib/set-defaults");
function libraryGenerator(host, schema) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const tasks = [];
        const options = (0, normalize_options_1.normalizeOptions)(host, schema);
        if (options.publishable === true && !schema.importPath) {
            throw new Error(`For publishable libs you have to provide a proper "--importPath" which needs to be a valid npm package name (e.g. my-awesome-lib or @myorg/my-lib)`);
        }
        if (!options.component) {
            options.style = 'none';
        }
        const initTask = yield (0, init_1.default)(host, Object.assign(Object.assign({}, options), { e2eTestRunner: 'none', skipFormat: true, skipHelperLibs: options.bundler === 'vite' }));
        tasks.push(initTask);
        (0, devkit_1.addProjectConfiguration)(host, options.name, {
            root: options.projectRoot,
            sourceRoot: (0, devkit_1.joinPathFragments)(options.projectRoot, 'src'),
            projectType: 'library',
            tags: options.parsedTags,
            targets: {},
        });
        const lintTask = yield (0, add_linting_1.addLinting)(host, options);
        tasks.push(lintTask);
        (0, create_files_1.createFiles)(host, options);
        // Set up build target
        if (options.buildable && options.bundler === 'vite') {
            const { viteConfigurationGenerator } = (0, devkit_1.ensurePackage)('@nx/vite', versions_1.nxVersion);
            const viteTask = yield viteConfigurationGenerator(host, {
                uiFramework: 'react',
                project: options.name,
                newProject: true,
                includeLib: true,
                inSourceTests: options.inSourceTests,
                includeVitest: options.unitTestRunner === 'vitest',
                compiler: options.compiler,
                skipFormat: true,
                testEnvironment: 'jsdom',
            });
            tasks.push(viteTask);
        }
        else if (options.buildable && options.bundler === 'rollup') {
            const rollupTask = yield (0, add_rollup_build_target_1.addRollupBuildTarget)(host, options);
            tasks.push(rollupTask);
        }
        // Set up test target
        if (options.unitTestRunner === 'jest') {
            const { configurationGenerator } = (0, devkit_1.ensurePackage)('@nx/jest', versions_1.nxVersion);
            const jestTask = yield configurationGenerator(host, Object.assign(Object.assign({}, options), { project: options.name, setupFile: 'none', supportTsx: true, skipSerializers: true, compiler: options.compiler, skipFormat: true }));
            tasks.push(jestTask);
            const jestConfigPath = (0, devkit_1.joinPathFragments)(options.projectRoot, options.js ? 'jest.config.js' : 'jest.config.ts');
            if (options.compiler === 'babel' && host.exists(jestConfigPath)) {
                const updatedContent = (0, jest_utils_1.updateJestConfigContent)(host.read(jestConfigPath, 'utf-8'));
                host.write(jestConfigPath, updatedContent);
            }
        }
        else if (options.unitTestRunner === 'vitest' &&
            options.bundler !== 'vite' // tests are already configured if bundler is vite
        ) {
            const { vitestGenerator } = (0, devkit_1.ensurePackage)('@nx/vite', versions_1.nxVersion);
            const vitestTask = yield vitestGenerator(host, {
                uiFramework: 'react',
                project: options.name,
                coverageProvider: 'c8',
                inSourceTests: options.inSourceTests,
                skipFormat: true,
                testEnvironment: 'jsdom',
            });
            tasks.push(vitestTask);
        }
        if (options.component) {
            const componentTask = yield (0, component_1.default)(host, {
                name: options.fileName,
                project: options.name,
                flat: true,
                style: options.style,
                skipTests: options.unitTestRunner === 'none' ||
                    (options.unitTestRunner === 'vitest' && options.inSourceTests == true),
                export: true,
                routing: options.routing,
                js: options.js,
                pascalCaseFiles: options.pascalCaseFiles,
                inSourceTests: options.inSourceTests,
                skipFormat: true,
                globalCss: options.globalCss,
            });
            tasks.push(componentTask);
        }
        if (options.publishable || options.buildable) {
            (0, devkit_1.updateJson)(host, `${options.projectRoot}/package.json`, (json) => {
                json.name = options.importPath;
                return json;
            });
        }
        if (!options.skipPackageJson) {
            const installReactTask = yield (0, install_common_dependencies_1.installCommonDependencies)(host, options);
            tasks.push(installReactTask);
        }
        const routeTask = (0, update_app_routes_1.updateAppRoutes)(host, options);
        tasks.push(routeTask);
        (0, set_defaults_1.setDefaults)(host, options);
        (0, create_ts_config_1.extractTsConfigBase)(host);
        if (!options.skipTsConfig) {
            (0, js_1.addTsConfigPath)(host, options.importPath, [
                (0, devkit_1.joinPathFragments)(options.projectRoot, './src', 'index.' + (options.js ? 'js' : 'ts')),
            ]);
        }
        if (!options.skipFormat) {
            yield (0, devkit_1.formatFiles)(host);
        }
        return (0, devkit_1.runTasksInSerial)(...tasks);
    });
}
exports.libraryGenerator = libraryGenerator;
exports.default = libraryGenerator;
exports.librarySchematic = (0, devkit_1.convertNxGenerator)(libraryGenerator);
