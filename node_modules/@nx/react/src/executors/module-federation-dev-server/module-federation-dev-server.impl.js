"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const devkit_1 = require("@nx/devkit");
const dev_server_impl_1 = require("@nx/webpack/src/executors/dev-server/dev-server.impl");
const path_1 = require("path");
const async_iterable_1 = require("@nx/devkit/src/utils/async-iterable");
const chalk = require("chalk");
const wait_for_port_open_1 = require("@nx/web/src/utils/wait-for-port-open");
const find_matching_projects_1 = require("nx/src/utils/find-matching-projects");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const tsnode_register_1 = require("@nx/js/src/utils/typescript/tsnode-register");
function getBuildOptions(buildTarget, context) {
    const target = (0, devkit_1.parseTargetString)(buildTarget, context.projectGraph);
    const buildOptions = (0, devkit_1.readTargetOptions)(target, context);
    return Object.assign({}, buildOptions);
}
function getModuleFederationConfig(tsconfigPath, workspaceRoot, projectRoot) {
    const moduleFederationConfigPathJS = (0, path_1.join)(workspaceRoot, projectRoot, 'module-federation.config.js');
    const moduleFederationConfigPathTS = (0, path_1.join)(workspaceRoot, projectRoot, 'module-federation.config.ts');
    let moduleFederationConfigPath = moduleFederationConfigPathJS;
    if ((0, fs_1.existsSync)(moduleFederationConfigPathTS)) {
        (0, tsnode_register_1.tsNodeRegister)(moduleFederationConfigPathTS, tsconfigPath);
        moduleFederationConfigPath = moduleFederationConfigPathTS;
    }
    try {
        const config = require(moduleFederationConfigPath);
        return config.default || config;
    }
    catch (_a) {
        throw new Error(`Could not load ${moduleFederationConfigPath}. Was this project generated with "@nx/react:host"?\nSee: https://nx.dev/concepts/more-concepts/faster-builds-with-module-federation`);
    }
}
function moduleFederationDevServer(options, context) {
    var _a, _b;
    return tslib_1.__asyncGenerator(this, arguments, function* moduleFederationDevServer_1() {
        const nxBin = require.resolve('nx');
        const currIter = (0, dev_server_impl_1.default)(options, context);
        const p = context.projectsConfigurations.projects[context.projectName];
        const buildOptions = getBuildOptions(options.buildTarget, context);
        const moduleFederationConfig = getModuleFederationConfig(buildOptions.tsConfig, context.root, p.root);
        const remotesToSkip = new Set((_a = (0, find_matching_projects_1.findMatchingProjects)(options.skipRemotes, context.projectGraph.nodes)) !== null && _a !== void 0 ? _a : []);
        if (remotesToSkip.size > 0) {
            devkit_1.logger.info(`Remotes not served automatically: ${[...remotesToSkip.values()].join(', ')}`);
        }
        const remotesNotInWorkspace = [];
        const knownRemotes = ((_b = moduleFederationConfig.remotes) !== null && _b !== void 0 ? _b : []).filter((r) => {
            const validRemote = Array.isArray(r) ? r[0] : r;
            if (remotesToSkip.has(validRemote)) {
                return false;
            }
            else if (!context.projectGraph.nodes[validRemote]) {
                remotesNotInWorkspace.push(validRemote);
                return false;
            }
            else {
                return true;
            }
        });
        if (remotesNotInWorkspace.length > 0) {
            devkit_1.logger.warn(`Skipping serving ${remotesNotInWorkspace.join(', ')} as they could not be found in the workspace. Ensure they are served correctly.`);
        }
        const remotePorts = knownRemotes.map((r) => context.projectGraph.nodes[r].data.targets['serve'].options.port);
        const devServeApps = !options.devRemotes
            ? []
            : Array.isArray(options.devRemotes)
                ? (0, find_matching_projects_1.findMatchingProjects)(options.devRemotes, context.projectGraph.nodes)
                : (0, find_matching_projects_1.findMatchingProjects)([options.devRemotes], context.projectGraph.nodes);
        devkit_1.logger.info(`NX Starting module federation dev-server for ${chalk.bold(context.projectName)} with ${knownRemotes.length} remotes`);
        const devRemoteIters = [];
        let isCollectingStaticRemoteOutput = true;
        for (const app of knownRemotes) {
            const appName = Array.isArray(app) ? app[0] : app;
            if (devServeApps.includes(appName)) {
                devRemoteIters.push(yield tslib_1.__await((0, devkit_1.runExecutor)({
                    project: appName,
                    target: 'serve',
                    configuration: context.configurationName,
                }, {
                    watch: true,
                }, context)));
            }
            else {
                let outWithErr = [];
                const staticProcess = (0, child_process_1.fork)(nxBin, [
                    'run',
                    `${appName}:serve-static${context.configurationName ? `:${context.configurationName}` : ''}`,
                ], {
                    cwd: context.root,
                    stdio: ['ignore', 'pipe', 'pipe', 'ipc'],
                });
                staticProcess.stdout.on('data', (data) => {
                    if (isCollectingStaticRemoteOutput) {
                        outWithErr.push(data.toString());
                    }
                    else {
                        outWithErr = null;
                        staticProcess.stdout.removeAllListeners('data');
                    }
                });
                staticProcess.stderr.on('data', (data) => devkit_1.logger.info(data.toString()));
                staticProcess.on('exit', (code) => {
                    if (code !== 0) {
                        devkit_1.logger.info(outWithErr.join(''));
                        throw new Error(`Remote failed to start. See above for errors.`);
                    }
                });
                process.on('SIGTERM', () => staticProcess.kill('SIGTERM'));
                process.on('exit', () => staticProcess.kill('SIGTERM'));
            }
        }
        return yield tslib_1.__await(yield tslib_1.__await(yield* tslib_1.__asyncDelegator(tslib_1.__asyncValues((0, async_iterable_1.combineAsyncIterables)(currIter, ...devRemoteIters, (0, async_iterable_1.createAsyncIterable)(({ next, done }) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (remotePorts.length === 0) {
                done();
                return;
            }
            try {
                yield Promise.all(remotePorts.map((port) => 
                // Allow 20 minutes for each remote to start, which is plenty of time but we can tweak it later if needed.
                // Most remotes should start in under 1 minute.
                (0, wait_for_port_open_1.waitForPortOpen)(port, {
                    retries: 480,
                    retryDelay: 2500,
                    host: 'localhost',
                })));
                isCollectingStaticRemoteOutput = false;
                devkit_1.logger.info(`NX All remotes started, server ready at http://localhost:${options.port}`);
                next({ success: true, baseUrl: `http://localhost:${options.port}` });
            }
            catch (_c) {
                throw new Error(`Timed out waiting for remote to start. Check above for any errors.`);
            }
            finally {
                done();
            }
        })))))));
    });
}
exports.default = moduleFederationDevServer;
